{"posts":[{"title":"test","content":"测试 ","link":"https://shxiaj.github.io/post/test/"},{"title":"Ps中索引色、RGB色 | Origin中导出RGB256色","content":"形形色色的，仿佛是bug的 1.伏笔 之前我一直很疑惑origin导出的tif图片，只有几十kb，明明300dpi，9cm的大小，觉得可能是图表色彩比较少存储空间用得少 2.起因 分析RMSF时，把&gt;0.2nm的resid全部画在了蛋白上，说明变得大的都不是二级结构方面。原本这图准备放SI里，结果觉得信息密度太低了，想了想可以放在RMSF的图里，就调调图腾个空放我的protein。用ps给这两合到一块去。 3.仿佛遇到了Bug 当我把origin导出的tif图放进ps里，再放protein图的时候，怎么也放不进去，以前都是这么叠加两张图的呀。打开关闭试了好几次，最后发现origin的图片显示的标志和普通的不一样啊。显示索引，图层也是被锁定的。 4.解决 Google喽，色深不同搞的，ps-&gt;图像-&gt;模式-&gt;rgb，调了即可，原来是默认的索引色只有256色，不能修改。 5.原来如此 origin里默认导出的tif是rgb，色深256色。就是ps里的索引颜色。 大概就是tif图片很小的原因吧。然后我又吃太饱了没事干，想看看256色和rgb24到底相差多少。 同样是300dpi，1063*815分辨率，9cm左右的大小。 果然大小相差很多啊，同时颜色没看出来任何区别，放大到163%时，256色的会有一点点不明显的灰色噪点，影响很小。 6.用处 图片太大，256色可以大大压缩图片大小。 ","link":"https://shxiaj.github.io/post/ps-256&rgb24/"},{"title":"gmx do_dssp & xpm2ps 蛋白二级结构图绘制","content":"又是无比折腾的一次体验，用到的文件都在最后可以下载 1.dssp gmx do_dssp 读取轨迹文件，并调用第三方程序 dssp 计算每一时间帧蛋白的二级结构。如果你尚未安装 dssp 程序，请到 http://swift.cmbi.ru.nl/gv/dssp 下载安装。 gmx do_dssp 假定 dssp 可执行文件的路径为 /usr/local/bin/dssp。 否则，需要设置一个环境变量 DSSP，其值为 dssp 可执行文件的完整路径， 例如在 csh 中可以使用：setenv DSSP=/opt/dssp/bin/dssp。如果使用 bash，可以使用 export DSSP='/opt/dssp/bin/dssp'，也可以直接将该变量添加到 bash 的配置文件 .bashrc 中。 # 选择protein组, 默认输出ss.xpm, 最好设置单位为ns, -dt 控制输出帧数，最好少点太多画图很难用 # 我用的1500帧，不多不少 echo 1 | gmx do_dssp -f md.xtc -s md.tpr -o -tu ns -dt 0.1 折腾的过程 1.原本在服务器使用这个，一点问题没有，可是当我在win本地使用时，没有dssp！ 这时候那没办法了，只能去找找了，网上说conda可以安装，结果试了半天，linux版的！没有conda的win版 然后又看见一篇知乎文章说，关注公众号领取，结果根本没有这个公众号！ 2.最后退而求其次只能使用linux的dssp了，找了半天，最终找到好人编译好的 http://bbs.keinsci.com/thread-14384-1-1.html 放在Wsl系统里, export DSSP=/dssp文件的全路径/ 在最后终于搞定了dssp。 3.然而当我把图全部搞完了过后，不死心，既然有人说有win版的，然后就找，通过几个关键字搜索终于找到了 唯一一个呀！ https://github.com/ecapriotti/lb1-2/tree/master/dssp 下载到win里，export DSSP=/XXX/dssp.exe 终于能用了 2.xpm2ps 使用xpm2ps工具将生成的ss.xpm 转换成 eps格式文件，用ps打开保存。 gmx xpm2ps默认的工具导出来会很奇怪，使用刘大佬的修改编译后的gmx_xpm2ps工具导出的图片格式比较正常美观 教程：http://bbs.keinsci.com/thread-20056-1-1.html # -bx -by 可以设置最终图的大小，不同情况需要字体调 # -di 输入的图片其他参数的设置 gmx_xpm2ps -f ss.xpm -o -bx 0.125 -by 0.25 -di ss.m2p black&amp;white = no linewidth = 1 titlefont = Helvetica titlefontsize = 5 legend = yes legendfont = Helvetica legendlabel = legend2label = legendfontsize = 5 xbox = 0 ybox = 0 等等~~ 具体看后面的下载链接，gmx手册里有对文件参数得详解 主要是字体大小需要调节，当图片大小为9cm*9cm时，上面设置比较合理 将输出的eps文件用ps打开，或者说用win画图工具，修修剪剪也可以 最终四个图和一块效果如下： 3.所用程序文件 软件加文件: dssp.exe gmx_xpm2ps.exe libmmd.dll ss.m2p 下载链接:dssp.7z 其他非必需的，帖子的提到的:https://pan.baidu.com/s/1WRUk7UJEW5oUPuEdCQNgRw?pwd=255s 提取码：255s ","link":"https://shxiaj.github.io/post/gmx-do_dssp/"},{"title":"Windows下的Linux基础环境 & 程序","content":"简洁美观，但是无比折腾 1.Linux基础环境 Git for Windows Portable 1.1 最快 首先那肯定最推荐64-bit Git for Windows Portable便捷版 其中包含了git awk sed bash等等常用的linux工具，使用自带的Bash.exe客户端也不用忍受的win的反斜杠 链接里下载便携版直接解压就行 https://git-scm.com/download/win 使用git-bash就能获得基础的linux使用环境了，bashrc在etc文件夹里。 1.2 进阶 再将里面的bin目录添加到win环境变量就能直接在cmd里 输入bash.exe打开git-bash了，由于电脑里还装了Wsl，命令还会冲突，所以我就把bin里文件改了个名字gbash，以防冲突 直接在文件管理器地址栏输入cmd回车打开工作目录就是当前的目录，再输入gbash就直接Ok了 1.3 折腾 自带cmd命令行，不好用，字体难找到美观的 win10应用商店搜索下载 terminal 程序，用来替代自带的cmd窗口。 我的莫名其妙，重启电脑了过后，文件夹右键菜单才才出现了‘在当前文件夹打开终端’这个选项，如果没出现网上搜索教程。 如图，这个界面才是流行的风格，舒服了。 里面集成了有Wsl、cmd、powersh的命令终端，添加一个新配置，同时设置新选项默认使用gsh打开界面 空白处右击，完美 1.4 总结 折腾折腾再折腾，看起来很简单，实际上试过很多其他的方式，轻量使用还是这个最为方便了。 win10在装个miniconda3，基本工具都有了。 想到一句话，差生文具多。 2.Gromacs win10编译版 win下编译Gromacs还是比较麻烦的，不过没事，有人帮编译好了呀。 sob的教程，同时也给出了编译好的文件了 http://sobereva.com/458 建议下载： 2020.6 CUDA GPU加速版，AVX2指令集（88 MB）：http://sobereva.com/soft/gmx/gmx2020.6_AVX2_CUDA_win64.rar（nVidia显卡驱动需&gt;=471.11版） 2018.8虽然小，但是和我的xtc轨迹文件不兼容呀，无语子。 解压，添加bin目录到win环境变量里 gmx使用，OK大功告成 然后后续使用还有小小坑，无语子，缺dssp。 实测分析轨迹数据还是很快的，我还是喜欢吧xtc文件搞到本地，处理出来各种xvg文件保存也比较方便 3. win10软件推荐 软件的第一要义，好看，不好看都是白扯，除非必须要用比如vmd，丑着丑着也就习惯了 3.1 字体 字体肯定是要用Source Code Pro，好看啊 3.1 sublime文本编辑器 可以收费，但是免费功能也一样，安装个汉化插件、Covert to Utf-8插件就能直接用了 优点是：高亮的颜色都比较舒服，写bash较方便; 各种软件内动画都非常的流畅，使用不卡顿 缺点：多行编辑不好用，不过我也没怎么用到过，字多的文档用sed、awk呗 所有的设置都是Json形式的，改改字体就行啦 还有个设置：当失去焦点时，自动保存。 好用啊 界面如图 设置json文件: { &quot;ignored_packages&quot;: [ &quot;Markdown&quot;, &quot;Rails&quot;, ], &quot;font_face&quot;:&quot;Source Code Pro&quot;, &quot;theme&quot;: &quot;Default.sublime-theme&quot;, &quot;color_scheme&quot;: &quot;Mariana.sublime-color-scheme&quot;, // &quot;translate_tabs_to_spaces&quot;: true, &quot;word_wrap&quot;: false, &quot;draw_white_space&quot;: &quot;all&quot;, &quot;font_size&quot;: 11, &quot;auto_find_in_selection&quot;: true, &quot;caret_style&quot;: &quot;smooth&quot;, &quot;ensure_newline_at_eof_on_save&quot;: true, &quot;index_files&quot;: false, &quot;save_on_focus_lost&quot;: true, &quot;open_files_in_new_window&quot;: false, &quot;update_check&quot;: false, &quot;dark_theme&quot;: &quot;Default.sublime-theme&quot;, &quot;light_theme&quot;: &quot;Default.sublime-theme&quot;, &quot;dark_color_scheme&quot;: &quot;MarkdownEditor-Dark.sublime-color-scheme&quot;, &quot;light_color_scheme&quot;: &quot;Monokai.sublime-color-scheme&quot;, } 3.2 ssh终端客户端 xshell6 虽然git bash也能用ssh，但是没怎么习惯用。 刚来的使用的secureCRT客户端，破解安装麻烦就不说了，界面怎么能那么的丑啊。 发现了这也就是我以前搞免流的时候用的类似软件，赶紧换成了xshell 一定要安装xmanager6，相当于全家桶，里面的组件能让你打开linux的gui图形软件，垃圾sCRT不行 不过要钱，只能下载Crack版喽，安装包就60M。舒服 xshell6：优点是好看，比xshell7安装包小很多，对于不习惯选中右键直接复制的我比较友好。 调个舒服的背景色就能用了 3.3 Cover 文件多窗口管理器 文件管理器多窗口标签页呗，流畅，不过肯定比不了原生的了 多窗口切换的我人都麻了，有了这个好很多 也有类似word的窗口，不好用，没必要，又开不了几个word 3.3 SingleFile 浏览器插件 保存网页页面的，好用就完事了。浏览器自带的保存，会出现一坨东西，这个就一个单个的html，方便的很 没有细看过图片是以什么方式编码在里面的呢？ 3.4 Adobe软件 windows画图工具原本是天下无敌的，结果终究是败了。 偶尔还是需要用到全家桶的，推荐一键安装的版本，啥也不用管，无脑且方便 搜索：Adobe系列软件大全 一键安装版 By：Ansifa Ansifa这个人的绿色版真滴方便呀 单个搜索也行，单个安装 3.5 PdgCntEditor目录（书签）编辑器 PdgCntEditor是什么？这是一个目录（书签）编辑器。当每次下载的PDF没有目录时，可以直接搜索书名，在购物平台的详情页一般都会有目录介绍。复制下来用该程序导入到PDF中，具体使用方法Google。 ","link":"https://shxiaj.github.io/post/win-linux-gmx/"},{"title":"gromacs画蛋白质残基接触图","content":"两种方法，一种感觉并不通用 A. gmx select工具 使用selec工具分析距离表面上方0.35nm以内的残基 使用mask.xvg分析占据比例，最后一步的index.dat画图 1. 分析残基接触比例 查看蛋白质残基的端基的resid序号, 结果为 9 506 # 输出蛋白质所有残基的id到index.dat gmx select -f md.gro -s md.tpr -select 'group protein' -oi -seltype res_com # 输出蛋白质端基序号 awk '{print $3 &quot; &quot; $NF}' index.dat 动态选区接触残基输出mask.xvg, 选中的为1 # 正电表面的厚度是1.632, 加上0.35即为选中的范围，resid 9 to 506上面得到的结果 # 200ns-300ns的统计结果 gmx select -f md.xtc -s md.tpr -select 'resid 9 to 506 and z &lt; 1.982' -tu ns -dt 0.1 -seltype res_com -oi -of -b 200 -e 300 接触占时间比例超过0.8的输出来，默认端基的id是从1开始的，所以awk输出+8 # print里+8按照resid实际情况修改一下 awk '!/^(#|@)/ {if ($2 &gt; 0.8) printf(&quot;%7d%10.4f\\n&quot;,$1+8,$2)}' occupancy.xvg 2. 残基接触图 输出全部时间的选区里的残基即可, dt 控制总帧数，不用搞太多 # 输出要用的index.dat，第一列时间，第二列所选取的数量，后面列是resid gmx select -f md.xtc -s md.tpr -select 'resid 9 to 506 and z &lt; 1.982' -tu ns -dt 0.1 -seltype res_com -oi # 用作Origin画残基接触图 awk '{for(i=3;i&lt;=NF;i++) printf(&quot;%8.2f%6d\\n&quot;,$1/1000,$i)}' index.dat &gt; resOrigin 用文件resOrigin导入origin画个散点图 B. gmx minidist工具, 更通用 1. gmx make_ndx 建立所有残基和表面的索引 # 先建立表面的索引, 如23和24为表面的原子 echo &quot;23|24\\nq\\n&quot; | gmx make_ndx -f md.tpr # 输出蛋白质所有残基的id到index.dat gmx select -f md.gro -s md.tpr -select 'group protein' -oi -seltype res_com # 输出蛋白质端基序号 awk '{print $3 &quot; &quot; $NF}' index.dat # 输出蛋白质残基序号到resid, 用于gmx make_ndx输入 awk '{for(i=3;i&lt;=NF;++i) print $i; print &quot;q&quot;}' index.dat &gt; resid # 生成单个的残基组 gmx make_ndx -f md.tpr -n &lt; resid 2. 计算距表面的最小距离 准备输入，输出。 例如index.ndx索引的第26个是表面，27-524是残基组 # 首先准备要输入的表面组和残基组 seq 26 524 &gt; minid # 计算最小距离，-ng x 表示第一个组与后面x组做计算，例如27-524一共498个 gmx mindist -f md.xtc -s md.tpr -n -od -tu ns -dt 0.1 -ng 498 &lt; mindid -od 输出的文件名默认是minidist.xvg 3. Python统计数据绘图 python分析minidist文件，举例总共300ns，1501帧。 默认端基以0输出，按照需要加某值，举例+9 resContactCal.py: import numpy as np # 残基吸附占据总时间的比例, &gt;0.8的残基输出 # 输入要统计的起始/结束帧, C端端基id # dist竟然是全局变量都不用传进方法里，离谱 def funOcc(began, end, beganID): occ = np.mean(dist[began:end, :], axis=0) for i in range(occ.size): if occ[i] &gt; 0.8: print(&quot;%5d%10.5f&quot; % (i + beganID, occ[i])) data = np.loadtxt('mindist.xvg', dtype=float, comments=['#', '@']) dist = data[:, 1:] # 距离小于0.35nm的赋值为1，大于赋值为0 index = dist &lt; 0.35 dist[index] = 1 dist[~index] = 0 # 可用可不用 funOcc(0, 501, 9) # 非零值的索引 index = np.nonzero(dist) originData = np.empty((index[0].size, 2)) originData[:, 0] = data[index[0], 0] originData[:, 1] = index[1] + 9 np.savetxt('resOrigin', originData, fmt='%7.2f%5d') # 废弃的for循环方法，巨呆 # for i in range(dist.shape[0]): # for j in range(dist.shape[1]): # if dist[i, j] == 0: # print(data[i, 0], j + 9) 用文件resOrigin导入origin画个散点图 A方法不好用于曲面，写判断也能写，不方便，没试过能不能用。 ","link":"https://shxiaj.github.io/post/resOrigin/"},{"title":"Vmd & Tcl 选区选择接触残基","content":"又是一个改良，用于建立索引，gmx rerun，Origin坐标 默认输出工作目录下的resContact文件中 选择原子按照需要更改 set aid [atomselect 0 {protein within 3.5 of {resname SDM SEM SAM SBM}}] proc resContact {} { # 选择接触残基的原子 set aid [atomselect 0 {protein within 3.5 of {resname SDM SEM SAM SBM}}] # 保存原子所在的id和name,具有重复值 set resids [$aid get resid] set resnames [$aid get resname] # 对resids去重为resid foreach i $resids {dict set resid $i 0} # for循环小写残基名，拼接上id，去重输出; for {set i 0} {$i &lt; [llength $resids]} {incr i} { dict set idname &quot;[string tolower [lindex $resnames $i] 1 end][lindex $resids $i]&quot; 0 } # 将变量值保存成文件,cat 获取 set fn [open &quot;resContact&quot; w+] puts $fn &quot;Build index:&quot; foreach i [dict keys $resid] {puts $fn &quot;r $i&quot;} puts $fn &quot;Build mdp:&quot; foreach i [dict keys $resid] {puts $fn &quot;r_$i&quot;} puts $fn &quot;Origin:&quot; foreach i [dict keys $idname] {puts $fn $i} close $fn exec cat resContact } ","link":"https://shxiaj.github.io/post/vmdTcl-ResContact/"},{"title":"function","content":"1.建模部分 # 获取gro文件Z轴最大值最小值 function g_zev { awk 'BEGIN {FIELDWIDTHS=&quot;36 8&quot;; min = 100} {if ($2 ~ /[0-9]\\.[0-9]{3}$/ &amp;&amp; \\ $2 &lt; min) min = $2} END {print min}' $1 awk 'BEGIN {FIELDWIDTHS=&quot;36 8&quot;; max = -50} {if ($2 ~ /[0-9]\\.[0-9]{3}$/ &amp;&amp; \\ $2 &gt; max) max = $2} END {print max}' $1 } # 调整蛋白质与表面位置 gro_adjust function g_adj { if [ -z $1 ]; then p1=&quot;ptw1.gro&quot;; else p1=$1; fi if [ -z $2 ]; then p2=&quot;ptw2.gro&quot;; else p2=$2; fi dist=$(awk 'BEGIN {FIELDWIDTHS=&quot;36 8&quot;; min = 100} {if ($2 ~ /[0-9]\\.[0-9]{3}$/ &amp;&amp; $2 &lt; min) min=$2} \\ END {dist = min - 0.6; print dist}' $p1 ) gmx editconf -f $p1 -o $p2 -translate 0 0 -${dist} } # 合并盒子 gro_merge function g_mer { if [ -z $1 ]; then echo &quot;No surface's .gro file&quot;; return; else surf=$1; fi if [ -z $2 ]; then p4=&quot;ptw4.gro&quot;; else p4=$2; fi sed '$d' $p4 &gt; box.gro sed '1,2d' $surf &gt;&gt; box.gro line_number=$((`cat box.gro|wc -l` - 3)) sed -i -e &quot;2s/.*/${line_number}/1&quot; box.gro } # 加个0.25的墙、调整ions.gro的Z值 function g_boxz { if [ -z $1 ]; then groFile=&quot;ions.gro&quot;; else groFile=$1; fi boxz=`awk 'BEGIN {FIELDWIDTHS=&quot;36 8&quot;; max = -50} {if ($2 ~ /[0-9]\\.[0-9]{3}$/ &amp;&amp; \\ $2 &gt; max) max = $2} END {print max+0.25}' $groFile` sed -i -e &quot;\\$s/[0-9]*.[0-9]*\\$/${boxz}/&quot; $groFile } function g_free { cur=($(sar -P ALL -u 1 1 | awk 'NR==40, NR==71 {print int($3)}')) if ((cur[0] &lt; 5)) ; then gpu_id=0; pinoffset=0 elif ((cur[4] &lt; 5)) ; then gpu_id=1; pinoffset=8 elif ((cur[8] &lt; 5)) ; then gpu_id=2; pinoffset=16 elif ((cur[12] &lt; 5)) ; then gpu_id=3; pinoffset=24 elif ((cur[16] &lt; 5)) ; then gpu_id=0; pinoffset=1 elif ((cur[20] &lt; 5)) ; then gpu_id=1; pinoffset=9 elif ((cur[24] &lt; 5)) ; then gpu_id=2; pinoffset=17 elif ((cur[28] &lt; 5)) ; then gpu_id=3; pinoffset=25 else gpu_id=5; echo -e &quot;$(date)\\nThere is no free\\n&quot;; fi if ((gpu_id != 5)); then echo -e &quot;$(date)\\nOK\\n&quot; mdParm=&quot;-pin on -ntmpi 1 -ntomp 4 -pinstride 2 -pme auto -nb gpu -gpu_id $gpu_id -pinoffset $pinoffset&quot; fi } function gmxem { gmx grompp -f em.mdp -c ions.gro -p topol.top -o ./em/em.tpr -po ./em/emout.mdp -n gmx mdrun -v -deffnm ./em/em $mdParm } function gmxnvt { gmx grompp -f nvt.mdp -c ./em/em.gro -p topol.top -o ./nvt/nvt.tpr -po ./nvt/nvtout.mdp -n -r ./em/em.gro gmx mdrun -v -deffnm ./nvt/nvt $mdParm } function gmxmd { gmx grompp -f md.mdp -c ./nvt/nvt.gro -p topol.top -o ./md/md.tpr -po ./md/mdout.mdp -n -r ./nvt/nvt.gro gmx mdrun -v -deffnm ./md/md $mdParm } function gmxrerun { gmx grompp -f energy.mdp -n -c ./nvt/nvt.gro -p topol.top -o ./ene-ProSurf/ene-ProSurf.tpr -po ./ene-ProSurf/ene-ProSurf.mdp gmx mdrun -v -rerun ./md/md.trr -deffnm ./ene-ProSurf/ene-ProSurf gmx grompp -f energy.mdp -n -c ./nvt/nvt.gro -p topol.top -o ./ene-ResSurf/ene-ResSurf.tpr -po ./ene-ResSurf/ene-ResSurf.mdp gmx mdrun -v -rerun ./md/md.trr -deffnm ./ene-ResSurf/ene-ResSurf } function gmx_model { cd model gmx genconf -f sam-cooh-unit.gro -o sam_cooh.gro -nbox 10 10 1 lines=($(java RandomGet)) ## 1 for i in ${lines[@]}; do sed -n &quot;/ ${i}SAM/p&quot; sam_cooh.gro done &gt; sbm.gro sed -i -e &quot;/SAM H/d; s/SAM/SBM/&quot; sbm.gro ## 2 for i in ${lines[@]}; do sed -i -e &quot;/ ${i}SAM/d&quot; sam_cooh.gro done ## 3 合并sam_cooh，sbm\\\\\\手动 tail -n 1 sam_cooh.gro &gt;&gt; sbm.gro sed -i -e &quot;\\$d&quot; sam_cooh.gro cat sbm.gro &gt;&gt; sam_cooh.gro atomNums=$((`cat sam_cooh.gro | wc -l` - 3)) sed -i -e &quot;2s/.*/${atomNums}/&quot; sam_cooh.gro cp sam_cooh.gro ../ cd - } # SAM表面的解离随机数 function randomGet { total=400 dissociation=84 array=($(seq $total)) for (( i = 0; i &lt; $dissociation; i++ )); do let last=total-i-1 let index=RANDOM%last let ret[i]=array[index] let array[index]=array[last] done echo ${ret[@]} | tr ' ' '\\n' | sort -n | tr '\\n' ' '| fold -sw 30; echo } # Check当前体系模拟状态 function check { runTime=$(tail -15 md.log | awk '{if($2==&quot;Time&quot;) flag=NR+1; if(NR==flag) printf(&quot;%d&quot;,$2)}') if [ ! -z $runTime ]; then echo 0 | gmx trjconv -f md.trr -s md.tpr -dump $runTime -o md_$runTime.gro fi } 2.Tcl Vmd部分 display projection orthographic rotate x by -90 rotate y by -90 proc bw {} { color Display Background white axes location Off display depthcue off light 2 on } proc bb {} { color Display Background black } proc bx {} { pbc box } proc sam {} { display resetview rotate x by -90 rotate y by -90 mol delrep 0 0 mol modcolor 0 0 Structure mol modstyle 0 0 NewCartoon 0.300000 10.000000 4.100000 0 mol color Structure mol representation NewCartoon 0.300000 10.000000 4.100000 0 mol selection not water mol material Glossy mol addrep 0 mol modselect 1 0 {resname SAM SBM SEM SDM} mol color Name mol representation Lines 1.000000 mol selection {resname SAM SBM SEM SDM} mol material Glossy mol addrep 0 mol modselect 2 0 resname FAD mol modcolor 2 0 Name mol color Name mol representation VDW 1.000000 12.000000 mol selection resname FAD mol material Glossy mol addrep 0 } proc pc {} { pbc wrap -center com -centersel &quot;protein&quot; -compound residue -all } # render picture proc renderPic {} { render Tachyon vmdscene.dat set fileName [clock seconds] exec tachyon_WIN32.exe vmdscene.dat -aasamples 24 -format BMP -mediumshade -trans_vmd -res 1200 1200 -o $fileName.bmp | echo $fileName.bmp } proc massCenter {} { set mcid [atomselect 0 &quot;protein or resname FAD&quot;] measure center $mcid weight mass } proc resContact {} { # 选择接触残基的原子 set aid [atomselect 0 {protein within 3.5 of {resname SDM SEM SAM SBM}}] # 保存原子所在的id和name,具有重复值 set resids [$aid get resid] set resnames [$aid get resname] # 对resids去重为resid foreach i $resids {dict set resid $i 0} # for循环小写残基名，拼接上id，去重输出; for {set i 0} {$i &lt; [llength $resids]} {incr i} { dict set idname &quot;[string tolower [lindex $resnames $i] 1 end][lindex $resids $i]&quot; 0 } # 将变量值保存成文件,cat 获取 set fn [open &quot;resContact&quot; w+] puts $fn &quot;Build index:&quot; foreach i [dict keys $resid] {puts $fn &quot;r $i&quot;} puts $fn &quot;Build mdp:&quot; foreach i [dict keys $resid] {puts $fn &quot;r_$i&quot;} puts $fn &quot;Origin:&quot; foreach i [dict keys $idname] {puts $fn $i} close $fn exec cat resContact } proc dipoles {dx dy dz} { set s 3 set t 0.9 set mc [massCenter] set mx [expr [lindex $mc 0]/10] set my [expr [lindex $mc 1]/10] set mz [expr [lindex $mc 2]/10] for {set i 0} {$i &lt; 1000} {incr i} { set dxi [expr $dx/$i] set dyi [expr $dy/$i] set dzi [expr $dz/$i] if {-$s &lt; $dxi &amp;&amp; $dxi &lt; $s &amp;&amp; -$s &lt; $dyi &amp;&amp; $dyi &lt; $s &amp;&amp; -$s &lt; $dzi &amp;&amp; $dzi &lt; $s} { break } } set x2 [expr ($mx+$dxi)*10] set y2 [expr ($my+$dyi)*10] set z2 [expr ($mz+$dzi)*10] set x3 [expr ($mx+$dx/($t*$i))*10] set y3 [expr ($my+$dy/($t*$i))*10] set z3 [expr ($mz+$dz/($t*$i))*10] set mx [expr $mx*10] set my [expr $my*10] set mz [expr $mz*10] set fn [open &quot;vmdDipoles&quot; w+] puts $fn [format &quot;偶极分量: %.3f %.3f %.3f&quot; $dx $dy $dz] puts $fn [format &quot;蛋白质心坐标(A): %.3f %.3f %.3f&quot; $mx $my $mz] puts $fn [format &quot;缩放偶极坐标(A): %.3f %.3f %.3f&quot; $x2 $y2 $z2] puts $fn [format &quot;偶极尖尖坐标(A): %.3f %.3f %.3f&quot; $x3 $y3 $z3] puts $fn &quot;缩放次数: $i&quot; puts $fn &quot;draw delete all\\ndraw color purple&quot; puts $fn [format &quot;draw cylinder {%.3f %.3f %.3f} {%.3f %.3f %.3f} radius 0.5 filled yes resolution 20&quot; $mx $my $mz $x2 $y2 $z2] puts $fn [format &quot;draw cone {%.3f %.3f %.3f} {%.3f %.3f %.3f} radius 1.5 resolution 20&quot; $x2 $y2 $z2 $x3 $y3 $z3] close $fn exec cat vmdDipoles | iconv -f UTF-8 -t GBK } # Jmol Style Color proc jmolColor {} { color change rgb 101 1.00 1.00 1.00 color change rgb 102 0.85 1.00 1.00 color change rgb 103 0.80 0.50 1.00 color change rgb 104 0.76 1.00 0.00 color change rgb 105 1.00 0.71 0.71 color change rgb 106 0.56 0.56 0.56 color change rgb 107 0.19 0.31 0.97 color change rgb 108 1.00 0.05 0.05 color change rgb 109 0.56 0.88 0.31 color change rgb 110 0.70 0.89 0.96 color change rgb 111 0.67 0.36 0.95 color change rgb 112 0.54 1.00 0.00 color change rgb 113 0.75 0.65 0.65 color change rgb 114 0.94 0.78 0.63 color change rgb 115 1.00 0.50 0.00 color change rgb 116 1.00 1.00 0.19 color change rgb 117 0.12 0.94 0.12 color change rgb 118 0.50 0.82 0.89 color change rgb 119 0.56 0.25 0.83 color change rgb 120 0.24 1.00 0.00 color change rgb 121 0.90 0.90 0.90 color change rgb 122 0.75 0.76 0.78 color change rgb 123 0.65 0.65 0.67 color change rgb 124 0.54 0.60 0.78 color change rgb 125 0.61 0.48 0.78 color change rgb 126 0.88 0.40 0.20 color change rgb 127 0.94 0.56 0.63 color change rgb 128 0.31 0.82 0.31 color change rgb 129 0.78 0.50 0.20 color change rgb 130 0.49 0.50 0.69 color change rgb 131 0.76 0.56 0.56 color change rgb 132 0.40 0.56 0.56 color change rgb 133 0.74 0.50 0.89 color change rgb 134 1.00 0.63 0.00 color change rgb 135 0.65 0.16 0.16 color change rgb 136 0.36 0.72 0.82 color change rgb 137 0.44 0.18 0.69 color change rgb 138 0.00 1.00 0.00 color change rgb 139 0.58 1.00 1.00 color change rgb 140 0.58 0.88 0.88 color change rgb 141 0.45 0.76 0.79 color change rgb 142 0.33 0.71 0.71 color change rgb 143 0.23 0.62 0.62 color change rgb 144 0.14 0.56 0.56 color change rgb 145 0.04 0.49 0.55 color change rgb 146 0.00 0.41 0.52 color change rgb 147 0.75 0.75 0.75 color change rgb 148 1.00 0.85 0.56 color change rgb 149 0.65 0.46 0.45 color change rgb 150 0.40 0.50 0.50 color change rgb 151 0.62 0.39 0.71 color change rgb 152 0.83 0.48 0.00 color change rgb 153 0.58 0.00 0.58 color change rgb 154 0.26 0.62 0.69 color change rgb 155 0.34 0.09 0.56 color change rgb 156 0.00 0.79 0.00 color change rgb 157 0.44 0.83 1.00 color change rgb 158 1.00 1.00 0.78 color change rgb 159 0.85 1.00 0.78 color change rgb 160 0.78 1.00 0.78 color change rgb 161 0.64 1.00 0.78 color change rgb 162 0.56 1.00 0.78 color change rgb 163 0.38 1.00 0.78 color change rgb 164 0.27 1.00 0.78 color change rgb 165 0.19 1.00 0.78 color change rgb 166 0.12 1.00 0.78 color change rgb 167 0.00 1.00 0.61 color change rgb 168 0.00 0.90 0.46 color change rgb 169 0.00 0.83 0.32 color change rgb 170 0.00 0.75 0.22 color change rgb 171 0.00 0.67 0.14 color change rgb 172 0.30 0.76 1.00 color change rgb 173 0.30 0.65 1.00 color change rgb 174 0.13 0.58 0.84 color change rgb 175 0.15 0.49 0.67 color change rgb 176 0.15 0.40 0.59 color change rgb 177 0.09 0.33 0.53 color change rgb 178 0.82 0.82 0.88 color change rgb 179 1.00 0.82 0.14 color change rgb 180 0.72 0.72 0.82 color change rgb 181 0.65 0.33 0.30 color change rgb 182 0.34 0.35 0.38 color change rgb 183 0.62 0.31 0.71 color change rgb 184 0.67 0.36 0.00 color change rgb 185 0.46 0.31 0.27 color change rgb 186 0.26 0.51 0.59 color change rgb 187 0.26 0.00 0.40 color change rgb 188 0.00 0.49 0.00 color change rgb 189 0.44 0.67 0.98 color change rgb 190 0.00 0.73 1.00 color change rgb 191 0.00 0.63 1.00 color change rgb 192 0.00 0.56 1.00 color change rgb 193 0.00 0.50 1.00 color change rgb 194 0.00 0.42 1.00 color change rgb 195 0.33 0.36 0.95 #Element color Element H 101 color Element He 102 color Element Li 103 color Element Be 104 color Element B 105 color Element C 106 color Element N 107 color Element O 108 color Element F 109 color Element Ne 110 color Element Na 111 color Element Mg 112 color Element Al 113 color Element Si 114 color Element P 115 color Element S 116 color Element Cl 117 color Element Ar 118 color Element K 119 color Element Ca 120 color Element Sc 121 color Element Ti 122 color Element V 123 color Element Cr 124 color Element Mn 125 color Element Fe 126 color Element Co 127 color Element Ni 128 color Element Cu 129 color Element Zn 130 color Element Ga 131 color Element Ge 132 color Element As 133 color Element Se 134 color Element Br 135 color Element Kr 136 color Element Rb 137 color Element Sr 138 color Element Y 139 color Element Zr 140 color Element Nb 141 color Element Mo 142 color Element Tc 143 color Element Ru 144 color Element Rh 145 color Element Pd 146 color Element Ag 147 color Element Cd 148 color Element In 149 color Element Sn 150 color Element Sb 151 color Element Te 152 color Element I 153 color Element Xe 154 color Element Cs 155 color Element Ba 156 color Element La 157 color Element Ce 158 color Element Pr 159 color Element Nd 160 color Element Pm 161 color Element Sm 162 color Element Eu 163 color Element Gd 164 color Element Tb 165 color Element Dy 166 color Element Ho 167 color Element Er 168 color Element Tm 169 color Element Yb 170 color Element Lu 171 color Element Hf 172 color Element Ta 173 color Element W 174 color Element Re 175 color Element Os 176 color Element Ir 177 color Element Pt 178 color Element Au 179 color Element Hg 180 color Element Tl 181 color Element Pb 182 color Element Bi 183 color Element Po 184 color Element At 185 color Element Rn 186 color Element Fr 187 color Element Ra 188 color Element Ac 189 color Element Th 190 color Element Pa 191 color Element U 192 color Element Np 193 color Element Pu 194 color Element Am 195 #Name color Name H 101 color Name O 108 color Name N 107 color Name C 106 color Name S 116 color Name P 115 # color Name L 103 # color Name F 109 #Type color Type H 101 color Type O 108 color Type N 107 color Type C 106 color Type S 116 color Type P 115 # color Type L 103 # color Type F 109 color change rgb 201 0.78 0.78 0.78 color change rgb 202 0.08 0.35 1.00 color change rgb 203 0.00 0.86 0.86 color change rgb 204 0.90 0.04 0.04 color change rgb 205 0.90 0.90 0.00 color change rgb 206 0.00 0.86 0.86 color change rgb 207 0.90 0.04 0.04 color change rgb 208 0.92 0.92 0.92 color change rgb 209 0.51 0.51 0.82 color change rgb 210 0.06 0.51 0.06 color change rgb 211 0.06 0.51 0.06 color change rgb 212 0.08 0.35 1.00 color change rgb 213 0.90 0.90 0.00 color change rgb 214 0.20 0.20 0.67 color change rgb 215 0.86 0.59 0.51 color change rgb 216 0.98 0.59 0.00 color change rgb 217 0.98 0.59 0.00 color change rgb 218 0.71 0.35 0.71 color change rgb 219 0.20 0.20 0.67 color change rgb 220 0.06 0.51 0.06 color change rgb 221 1.00 0.41 0.71 color change rgb 222 1.00 0.41 0.71 #Resname color Resname ALA 201 color Resname ARG 202 color Resname ASN 203 color Resname ASP 204 color Resname CYS 205 color Resname GLN 206 color Resname GLU 207 color Resname GLY 208 color Resname HIS 209 color Resname ILE 210 color Resname LEU 211 color Resname LYS 212 color Resname MET 213 color Resname PHE 214 color Resname PRO 215 color Resname SER 216 color Resname THR 217 color Resname TRP 218 color Resname TYR 219 color Resname VAL 220 # structure color change rgb 301 1.000 0.000 0.502 color change rgb 302 0.627 0.000 0.502 color change rgb 303 0.376 0.000 0.502 color change rgb 304 1.000 0.784 0.000 color change rgb 305 0.376 0.502 1.000 color change rgb 306 1.000 1.000 1.000 color Structure {Alpha Helix} 301 color Structure {3_10_Helix} 302 color Structure {Pi_Helix} 303 color Structure {Extended_Beta} 304 color Structure {Bridge_Beta} 306 color Structure {Turn} 305 color Structure {Coil} 306 } 3.其他 # 大写文件名 for fileName in `ls | grep mp4`; do temp=${fileName%%.*} newName=${temp^^}-.${fileName##*.} mv ${fileName} ${newName} done ","link":"https://shxiaj.github.io/post/function/"},{"title":"Tcl绘制Vmd里面的静电偶级","content":"重写了diploes.sh，更快更方便 调用方法: diploes x y z ?s ?t x y z 分别代表Mtot.xvg的三个分量，Mtot.xvg 由gmx dipoles获得 s t 分别都有默认值3，0.9，分别控制圆柱的长度和圆锥的长度, 是可选输入 依赖 massCenter 函数的结果，在最下面。 执行完成后，会在工作目录生成vmdDipoles文件，查看即可 同时可能会默认输出，看电脑环境变量的设置 # dipoles过程 proc dipoles {dx dy dz {s 3} {t 0.9}} { set mc [massCenter] set mx [expr [lindex $mc 0]/10] set my [expr [lindex $mc 1]/10] set mz [expr [lindex $mc 2]/10] for {set i 0} {$i &lt; 1000} {incr i} { set dxi [expr $dx/$i] set dyi [expr $dy/$i] set dzi [expr $dz/$i] if {-$s &lt; $dxi &amp;&amp; $dxi &lt; $s &amp;&amp; -$s &lt; $dyi &amp;&amp; $dyi &lt; $s &amp;&amp; -$s &lt; $dzi &amp;&amp; $dzi &lt; $s} { break } } set x2 [expr ($mx+$dxi)*10] set y2 [expr ($my+$dyi)*10] set z2 [expr ($mz+$dzi)*10] set x3 [expr ($mx+$dx/($t*$i))*10] set y3 [expr ($my+$dy/($t*$i))*10] set z3 [expr ($mz+$dz/($t*$i))*10] set mx [expr $mx*10] set my [expr $my*10] set mz [expr $mz*10] set fn [open &quot;vmdDipoles&quot; w+] puts $fn [format &quot;偶极分量: %.3f %.3f %.3f&quot; $dx $dy $dz] puts $fn [format &quot;蛋白质心坐标(A): %.3f %.3f %.3f&quot; $mx $my $mz] puts $fn [format &quot;缩放偶极坐标(A): %.3f %.3f %.3f&quot; $x2 $y2 $z2] puts $fn [format &quot;偶极尖尖坐标(A): %.3f %.3f %.3f&quot; $x3 $y3 $z3] puts $fn &quot;缩放次数: $i&quot; puts $fn &quot;draw delete all\\ndraw color purple&quot; puts $fn [format &quot;draw cylinder {%.3f %.3f %.3f} {%.3f %.3f %.3f} radius 0.5 filled yes resolution 20&quot; $mx $my $mz $x2 $y2 $z2] puts $fn [format &quot;draw cone {%.3f %.3f %.3f} {%.3f %.3f %.3f} radius 1.5 resolution 20&quot; $x2 $y2 $z2 $x3 $y3 $z3] close $fn # 调用cat命令查看文件，不全部都有用 exec cat vmdDipoles | iconv -f UTF-8 -t GBK } # massCenter过程 proc massCenter {} { set mcid [atomselect 0 &quot;protein or resname FAD&quot;] measure center $mcid weight mass } ","link":"https://shxiaj.github.io/post/tclVmdDipoles/"},{"title":"Pymol 计算蛋白质静电势，渲染导出动画","content":" 安装Pymol开源版 参考：https://blog.csdn.net/weixin_45564533/article/details/115671036 conda install -c conda-forge pymol-open-source 无语了，开源版没计算的工具，卸载吧 conda uninstall pymol-open-source 安装非开源版Pymol https://anaconda.org/schrodinger/pymol conda install -c schrodinger pymol 申请教育用户证书，我已经申请过了，点连接下载，输入密码，下载2.0版本的 Thank you for your interest in PyMOL. DOWNLOAD URL: https://pymol.org/ep USERNAME: jun2021 PASSWORD: betabarrel 或者直接点下面的连接 PyMOL 2.0 (September 2017) License File: pymol-edu-license.lic 然后导入 搞定 画静电势 导入蛋白质，点plugin---apbs---run，无脑下一步 完成后就这样 渲染导出保存图片和视频 # 设置背景为白色 bg_color white # 所有的图片都能保存为PNG格式，通过&quot;png&quot;命令或&quot;File&quot;菜单的&quot;Export Image As&quot;选项。图片通常被保存为和viewer 窗口一样的大小： ray cd desktop png my_image.png # 或者通过下面的命令可改变图片大小：语法 ray width,height # 宽和高都必须是整数，它们的默认是零或当前窗口大小 # 例如 ray 1024,480 # 更多关于ray的信息通过命令“help ray”获得。 渲染视频 mset 1 x120 #定义动画 util.mroll 1,120,1 #mdo命令创建旋转360度的120帧动画 点击播放图标即可预览 相关的教程： 保存视频 也可以先去掉底下的颜色标尺在保存，框里其中某一个点击关闭就行 大功告成 渲染出来的视频.mp4 完结撒花 相关的有用的教程 Pymol-CommandLine Frontiers | A script to highlight hydrophobicity and charge on protein surfaces | Molecular Biosciences https://www.frontiersin.org/articles/10.3389/fmolb.2015.00056/full PyMOL中文教程 — PyMOL中文教程 2020.09 文档 http://pymol.chenzhaoqiang.com/index.html pymol 教程 https://360ai.org/pymol 最相关的教程 PyMOL tutorial -Hydrophobicity- http://www.protein.osaka-u.ac.jp/rcsfp/supracryst/suzuki/jpxtal/Katsutani/en/hydrophobicity.php Displaying Biochemical Properties - PyMOLWiki https://pymolwiki.org/index.php/Displaying_Biochemical_Properties ","link":"https://shxiaj.github.io/post/pymolPlot/"},{"title":"Sublime Text 右键打开当前文件夹","content":"使用sublime 右键打开资源管理器里的当前文件夹 1. 打开注册表编辑器 Win+R打开运行工具，输入regedit，回车运行 2. 建立右键打开项 点开HKEY_CLASSES_ROOT\\Directory\\shell； 当前文件夹新建一个新的项，命名为sublime，设置默认值Open Folder as SublimeText，这个默认值是显示在右键名称上的; 新建一个字符串值，命名为Icon，设置值为C:\\Program Files\\Sublime Text\\sublime_text.exe（具体程序位置） sublime里再新建一个项，命名为command，设置默认值为C:\\Program Files\\Sublime Text\\sublime_text.exe %1（具体程序位置加上 %1）； OK，完成。 3. 测试 实际如下图 ","link":"https://shxiaj.github.io/post/sublime-text/"},{"title":"记录Bug","content":"遇到的bug解决方式 - Mybatis 日志 Reader entry 乱码问题 分析：上述日志有两处问题 org.jboss.vfs.VFS 没找到 Reader entry 乱码 由上面两处问题大致可以猜测是由于指定的VFS没有找，mybatis启用了默认的DefaultVFS，然后由于DefaultVFS的内部逻辑，从而导致了reader entry乱码。 所以解决问题的切入点有两个。1: org.jboss.vfs.VFS 2:修改DefaultVFS 追加org.jboss.vfs.VFS相关的依赖 由于我是用maven来构建的项目，所以直接加入下面的依赖 &lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jboss-vfs&lt;/artifactId&gt; &lt;version&gt;3.2.15.Final&lt;/version&gt; &lt;/dependency&gt; ———————————————— 版权声明：本文为CSDN博主「小菜鸡wangyan」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/qq_44318273/article/details/114363584 - Mybatis配置插件报错 配置mybatis的配置文件插入plugins标签时，在根目录报错。原因是：根目录下的标签必须按照它规定的循序排列 The content of element type &quot;configuration&quot; must match &quot;(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)&quot;. ","link":"https://shxiaj.github.io/post/ji-lu-bug/"},{"title":"Awk，Python与各种小工具","content":"我使用过的功能 1. Awk awk 正则匹配语法：regexp[https://www.runoob.com/regexp/regexp-syntax.html] awk BEGIN+过滤+主体{}+END 语法编写顺序 awk 'BEGIN{i = 1} !/^(#|@)/ {theta = $4 / $5; print $1 &quot; &quot; theta}' Mtot.xvg &gt; dipoles awk 命令行与脚本实例对比 awk '!/^(#|@)/ {for (i = 2; i &lt;= NF; ++i) {freq[i] += $i; print freq[i] &quot; &quot; $i &quot; &quot; i}} END {print NR; for(i in freq) printf(&quot;%8.3f\\n&quot;,freq[i]/NR*2)}' #!/usr/bin/awk -f # awk解释器位置 BEGIN { T = 2; printf(&quot;ok\\n&quot;); } # 正则匹配模式，必须连接在一起 !/^(#|@)/ { for (i = 2; i &lt;= NF; ++i) { freq[i] += $i; #print $0; } } END { print NR; for(i in freq) printf(&quot;%15.3f&quot;, freq[i] / NR * T); printf(&quot;\\n&quot;); } 1.1 传递数组 当需要shell的数组时，把shell当成字符串输入，awk里在使用split()函数将其分解； awk使用的是扩展的正则表达式；awk字符串函数说明 字符串函数教程 正则表达式语法 在使用if语句的时候，一定要加{}，就算后面只有一条语句也得加，否则不会执行。大大的教训 改变$1 $2的结果时，同时也会改变$0的值，但是这时候的$0，会自作多情的给你在每列值之间添加上空格分隔符。所以当改变列值时，要么使用printf格式化输出每列值，要么就$1 $2 $3....一个个打出来 # substr 提取字符串，awk字符串索引竟然是从1开始的 awk '{atomName=substr($12,1,1) substr($3,2);print atomName}' unit.pdb &gt; unit # awk筛选行, gsub替换字符串 awk -v arr=&quot;$(cat unit)&quot; ' BEGIN { FIELDWIDTHS=&quot;8 7 53&quot;; split(arr,atomName); i=-1; len=length(atomName) } { if (i &gt; len) {i -= len}; if (NR &gt; 2 &amp;&amp; NR &lt; 45723) {gsub(&quot;[^[:space:]].*$&quot;, atomName[i], $2)}; print $1 $2 $3; i++;}' nvt.gro &gt; tt.gro # 简单的方法就可以完成，根本用不着替换字符串，方向错了 # linux适用 awk '{atomName=substr($12,1,1) substr($3,2);print atomName}' unit.pdb &gt; unit awk -v arr=&quot;$(cat unit)&quot; 'BEGIN {FIELDWIDTHS=&quot;8 7 53&quot;; split(arr,atomName);i=-1;len=length(atomName)} {if (i &gt; len) {i -= len} if ($1 ~ /PCA/) {printf(&quot;%s%7s%s\\n&quot;,$1,atomName[i],$3)} else {print $0} i++;}' nvt.gro &gt; tt.gro # linux上显示参数过多，win可以 awk '{atomName=substr($12,1,1) substr($3,2);print atomName}' pc.pdb &gt; pc awk -v arr=&quot;$(awk '{atomName=substr($12,1,1) substr($3,2);print atomName}' pc.pdb)&quot; 'BEGIN { FIELDWIDTHS=&quot;8 7 53&quot;; split(arr,atomName);} {if ($1 ~ /PCA/) {printf(&quot;%s%7s%s\\n&quot;,$1,atomName[NR-2],$3)} else {print $0} }' nvt.gro &gt; tt.gro 统计一下下rmsd&gt;0.2的resid awk '{if($2&gt;0.2||$3&gt;0.2||$4&gt;0.2||$5&gt;0.2||$6&gt;0.2) {print $0}}' rmsf.dat # 打印数字时，第一个数字出现了bug显示为0，不知道为什么还是使用%s吧 awk '{if($2&gt;0.2||$3&gt;0.2||$4&gt;0.2||$5&gt;0.2||$6&gt;0.2) printf(&quot;%d &quot;,$1)}' rmsf.dat awk '{if($2&gt;0.2||$3&gt;0.2||$4&gt;0.2||$5&gt;0.2||$6&gt;0.2) printf(&quot;%s &quot;,$1)}' rmsf.dat &gt; rmsfGreater2A # 破案了格式问题dos2unix即可，发现不正常的文件读取大概率都是这个原因 4. Sed用法 详细的教程，虽然没看过但是肯定有用sed教程 3. ffmpeg 转换图片格式 ffmpeg -hide_baatomNameer -y -i $fileName.bmp -pix_fmt rgb24 -c tiff -compression_algo lzw $fileName.tif 2. Python import matplotlib # 使用非交互后端，加速运行速度 matplotlib.use('Agg') conda clean -p #删除没有用的包 conda clean -t #tar打包 conda clean -y -a #删除所有的安装包及cache conda config --set changeps1 false #关闭conda的环境提示 ","link":"https://shxiaj.github.io/post/shells-note/"},{"title":"MySQL-笔记","content":"MySQL记录笔记 设置密码 update user set authentication_string=password(&quot;dingliang&quot;) where user='root'; SQL语句分类 SQL语句有很多，最好进行分门别类，这样更容易记忆。 分为： DQL： 数据查询语言（凡是带有select关键字的都是查询语句） select... DML： 数据操作语言（凡是对表当中的数据进行增删改的都是DML） insert delete update insert 增 delete 删 update 改 这个主要是操作表中的数据data。 DDL： 数据定义语言 凡是带有create、drop、alter的都是DDL。 DDL主要操作的是表的结构。不是表中的数据。 create：新建，等同于增 drop：删除 alter：修改 这个增删改和DML不同，这个主要是对表结构进行操作。 TCL： 不是王牌电视。 是事务控制语言 包括： 事务提交：commit; 事务回滚：rollback; DCL： 是数据控制语言。 例如：授权grant、撤销权限revoke.... 1.分组函数 分组函数不能够直接使用在where子句中，因为分组函数在使用的时候必须先分组之后才能使用。 where执行的时候，还没有分组。所以where后面不能出现分组函数。 在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。 使用having可以对分完组之后的数据进一步过滤。 having不能单独使用，having不能代替where，having必须 和group by联合使用。 2.执行顺序 书写顺序？ select ... from ... where ... group by ... having ... order by 执行顺序？ 1. from 2. where 3. group by 4. having 5. select 6. order by 3.子查询 select语句中嵌套select语句 select ..(select). from ..(select). where ..(select). # example select ename,sal from emp where sal &gt; (select min(sal) from emp); # example select s.GRADE, t.job, t.avgsal from (select job, avg(sal) as avgsal from emp group by job) t join salgrade s on t.avgsal between s.losal and s.hisal group by s.GRADE, t.avgsal, t.job ; 4.union合并查询结果集 select ename,job from emp where job = 'MANAGER' or job = 'SALESMAN'; select ename,job from emp where job in('MANAGER','SALESMAN'); # 替换方式 select ename,job from emp where job = 'MANAGER'; union select ename,job from emp where job = 'SALESMAN'; union的效率要高一些。对于表连接来说，每连接一次新表， 则匹配的次数满足笛卡尔积，成倍的翻。。。 但是union可以减少匹配的次数。在减少匹配次数的情况下， 还可以完成两个结果集的拼接。 union在进行结果集合并的时候，要求两个结果集的列数相同 结果集合并时列和列的数据类型也要一致 5.limit(非常重要) 完整用法：limit startIndex, length startIndex是起始下标，length是长度。 起始下标从0开始。 select ename, sal from emp order by sal desc limit 20; select ... from ... where ... group by ... having ... order by ... limit ... limit在order by之后执行！！！！！！ 6.creat create table 表名(字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型); 7.insert insert into 表名(字段名1,字段名2,字段名3...) values(值1,值2,值3); 8.update update 表名 set 字段名1=值1,字段名2=值2,字段名3=值3... where 条件; ","link":"https://shxiaj.github.io/post/mysql/"},{"title":"自定义修改主题字体样式","content":"修改代码块字体 代码块背景颜色 通过使用的模板生成静态html ","link":"https://shxiaj.github.io/post/edit-css/"},{"title":"MySQL-Win10下压缩包安装方式","content":"简洁方式，方便使用和卸载 1、下载MySQL MySQL社区版下载地址 https://downloads.mysql.com/archives/community/ 2、解压压缩包 3、配置Win10系统环境变量 配置系统环境变量，方法百度 path路径中添加F:\\JavaProject\\mysql-5.7.35\\bin 4、配置my.ini，MySQL配置文件 新建my.ini文件在MySQL解压完成的目录下 my.ini文件内容 [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置3306端口 port = 3306 # 设置mysql的安装目录，都为自己安装目录 basedir=F:\\JavaProject\\mysql-5.7.35 # 设置mysql数据库的数据的存放目录 datadir=F:\\JavaProject\\mysql-5.7.35\\data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 跳过密码登录，可选择是否开启 # skip-grant-tables 5、安装MySQL服务 bin目录中运行cmd，使用管理员身份 使用cmd命令初始化和启动MySQL服务，生成data文件夹，如果出现下面情况2，删除data文件夹重新输入命令即可 cd /d F:\\JavaProject\\mysql-5.7.35\\bin mysqld --initialize-insecure mysqld -install # mysqld --initialize-insecure（建议使用，不设置root密码） # mysqld --initialize （不建议使用，生成一个随机的root密码） net start mysql启动MySQL服务 6、运行MySQL服务 # 直接cmd中运行，输入密码时，直接按回车键可以直接登录 mysql -u root -p # 设置密码 '' 单引号中间为root密码，然后再刷新 SET PASSWORD FOR 'root'@'localhost' = PASSWORD('ding'); flush privileges; quit; # 关闭重新启动 net stop mysql net start mysql # 再次使用root登录，输入设置好的密码 mysql -u root -p 出现这种错误都是由于MySQL服务没有启动，必须在管理员权限下的cmd中使用net start mysql启动服务 OK，完成，尽情学习MySQL数据库！ ","link":"https://shxiaj.github.io/post/mysql-win10/"},{"title":"Java-learnRoad","content":"2021-12-010809 ⭐ 尚硅谷最新版 JavaWeb 全套教程：https://www.bilibili.com/video/BV1Y7411K7zz 只是看完了，后面几乎没有实操，325集可太多了，人都看麻了。 我需要一个思维导图整理思路，其中的代码就不一一敲了。 复习整理一天的思维导图 ","link":"https://shxiaj.github.io/post/java-learnroad/"},{"title":"Clash-paperRule","content":"文献网站直接代理 Clash文献出版社直接代理规则 在校使用校园网浏览下载文献时，跳过这些出版社的网站代理 - DOMAIN-SUFFIX,deepl.com,DIRECT - DOMAIN-SUFFIX,manual.gromacs.org,DIRECT - DOMAIN-KEYWORD,sci-hub,DIRECT - DOMAIN-SUFFIX,ccdc.cam.ac.uk,DIRECT - DOMAIN-KEYWORD,wiley,DIRECT - DOMAIN-KEYWORD,pubs,DIRECT - DOMAIN-KEYWORD,translate,DIRECT - DOMAIN-KEYWORD,docs,DIRECT - DOMAIN-KEYWORD,onenote,DIRECT - DOMAIN-KEYWORD,office,DIRECT - DOMAIN-KEYWORD,microsoft,DIRECT - DOMAIN-SUFFIX,digicert.com,DIRECT - DOMAIN-SUFFIX,sciencedirect.com,DIRECT - DOMAIN-SUFFIX,iresearchbook.cn,DIRECT - DOMAIN-SUFFIX,elsevier.com,DIRECT - DOMAIN-SUFFIX,nature.com,DIRECT - DOMAIN-SUFFIX,webofknowledge.com,DIRECT - DOMAIN-SUFFIX,pubs.acs.org,DIRECT - DOMAIN-SUFFIX,scitation.org,DIRECT ","link":"https://shxiaj.github.io/post/clash-paperrule/"},{"title":"Intellij Idea 创建动态Web项目&配置Tomcat","content":"没有写，呼呼 ","link":"https://shxiaj.github.io/post/IdeaJ/"},{"title":"单调栈 LeetCode","content":" 单调栈 单调栈：这题考的基础模型其实就是：在一维数组中对每一个数找到第一个比自己小的元素。 这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。 重要的是：将问题转化成找到下一个 比当前值大/小的 值的下标 package leetcode; import java.util.*; public class MonotonousStackDemo { public static void main(String[] args) { } } /** * 84. 柱状图中最大的矩形 */ /* 空间优化 概括的说：矩形高度相等的时候，虽然按照左边柱子来算，答案不对，但是最右边的来算，结果是对的，我们只需要保存一个正确的就可。 等等，我们需要的是「一根柱子的右侧且最近的小于其高度的柱子」，但这里我们求的是小于等于，那么会造成什么影响呢？ 答案是：我们确实无法求出正确的右边界，但对最终的答案没有任何影响。 这是因为在答案对应的矩形中，如果有若干个柱子的高度都等于矩形的高度，那么最右侧的那根柱子是可以求出正确的右边界的， 而我们没有对求出左边界的算法进行任何改动，因此最终的答案还是可以从最右侧的与矩形高度相同的柱子求得的。 */ class Solution { public int largestRectangleArea(int[] heights) { int n = heights.length; int[] left = new int[n]; int[] right = new int[n]; Arrays.fill(right, n); Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { while (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) { right[stack.pop()] = i; } left[i] = stack.isEmpty() ? -1 : stack.peek(); stack.push(i); } int ans = 0; for (int i = 0; i &lt; n; i++) { int area = (right[i] - left[i] - 1) * heights[i]; ans = Math.max(ans, area); } return ans; } } // 先左后右，记住当前柱子左侧和右侧小于其高度的柱子下标 class Solution130 { public int largestRectangleArea(int[] heights) { int n = heights.length; int[] left = new int[n]; int[] right = new int[n]; Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { while (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) { stack.pop(); } left[i] = stack.isEmpty() ? -1 : stack.peek(); stack.push(i); } // 忘记清除 stack.clear(); for (int i = n - 1; i &gt;= 0; i--) { while (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) { stack.pop(); } right[i] = stack.isEmpty() ? n : stack.peek(); stack.push(i); } int ans = 0; for (int i = 0; i &lt; n; i++) { int area = (right[i] - left[i] - 1) * heights[i]; ans = Math.max(ans, area); } return ans; } } /** * 42. 接雨水 */ // 单调栈，按行计算；前两种方法用的都是按列计算雨水数量 class Solution129 { public int trap(int[] height) { int ans = 0; Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); int n = height.length; for (int i = 0; i &lt; n; i++) { while (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) { int top = stack.pop(); if (stack.isEmpty()) break; int left = stack.peek(); int wid = i - left - 1; int hgh = Math.min(height[left], height[i]) - height[top]; ans += wid * hgh; } stack.push(i); } return ans; } } // 动态规划 class Solution128 { public int trap(int[] height) { int n = height.length; int[] lMax = new int[n]; int[] rMax = new int[n]; lMax[0] = height[0]; for (int i = 1; i &lt; n; i++) { lMax[i] = Math.max(lMax[i - 1], height[i]); } rMax[n - 1] = height[n - 1]; for (int i = n - 2; i &gt;= 0; i--) { rMax[i] = Math.max(rMax[i + 1], height[i]); } int ans = 0; for (int i = 0; i &lt; n; i++) { int count = Math.min(lMax[i], rMax[i]) - height[i]; System.out.println(ans); if (count &gt; 0) ans += count; } System.out.println(Arrays.toString(lMax)); System.out.println(Arrays.toString(rMax)); return ans; } } // 巧妙的双指针 class Solution127 { public int trap(int[] height) { int ans = 0; int left = 0, right = height.length - 1; int leftMax = 0, rightMax = 0; // left &lt; right；相遇的时候，left与right一定为最大值 // left &lt;= right也可以，最大值时计算ans += 0； while (left &lt; right) { leftMax = Math.max(leftMax, height[left]); rightMax = Math.max(rightMax, height[right]); if (height[left] &lt; height[right]) { ans += leftMax - height[left]; left++; } else { ans += rightMax - height[right]; right--; } } return ans; } } /** * 503. 下一个更大元素 II */ class Solution126 { public int[] nextGreaterElements(int[] t) { LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); int[] ret = new int[t.length]; Arrays.fill(ret, -1); for (int i = 0; i &lt; t.length * 2; i++) { int j = i % t.length; while (!stack.isEmpty() &amp;&amp; t[j] &gt; t[stack.peek()]) { ret[stack.peek()] = t[j]; stack.pop(); } stack.push(j); } return ret; } } /** * 496. 下一个更大元素 I */ class Solution125 { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int[] ret = new int[nums1.length]; Arrays.fill(ret, -1); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums1.length; i++) { map.put(nums1[i], i); } LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); stack.push(0); for (int i = 0; i &lt; nums2.length; i++) { while (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) { int val = nums2[stack.peek()]; if (map.containsKey(val)) { ret[map.get(val)] = nums2[i]; } stack.pop(); } stack.push(i); } return ret; } } /** * 739. 每日温度 */ // 使用LinkedList当做栈比Stack要快很多啊 // Stack底层实现是数组 class Solution124 { public int[] dailyTemperatures(int[] t) { LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); int[] ret = new int[t.length]; stack.push(0); for (int i = 1; i &lt; t.length; i++) { while (!stack.isEmpty() &amp;&amp; t[i] &gt; t[stack.peek()]) { ret[stack.peek()] = i - stack.pop(); } stack.push(i); } return ret; } } class Solution123 { public int[] dailyTemperatures(int[] t) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] ret = new int[t.length]; stack.push(0); for (int i = 1; i &lt; t.length; i++) { while (!stack.isEmpty() &amp;&amp; t[i] &gt; t[stack.peek()]) { ret[stack.peek()] = i - stack.pop(); } stack.push(i); } return ret; } } ","link":"https://shxiaj.github.io/post/java-MonotonousStack/"},{"title":"背包问题 LeetCode","content":" 0-1背包问题 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。 使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大。 使用一维数组更为简洁。 0-1背包和完全背包唯一不同就是体现在遍历顺序上，从一维数组看，第二个遍历过程0-1是从后往前，完全背包是从前往后 package leetcode; import java.util.Arrays; public class BagDemo { public static void main(String[] args) { int[] weight = {1, 3, 4}; int[] value = {15, 20, 30}; // 物品的数量 int num = weight.length; // 背包容量 int vol = 4; int[][] dp = new int[num][vol + 1]; // 初始化dp数组, 第一行从背包容量等于物品质量开始，剪枝 for (int j = weight[0]; j &lt;= vol; j++) { dp[0][j] = value[0]; } // 遍历行，即先遍历物品，数量从小到多 for (int i = 1; i &lt; num; i++) { // 再遍历列，即遍历容量，从小到大 for (int j = 1; j &lt;= vol; j++) { // 如果当前背包容量小于当前物品重量，无法放入， // 最大值等于不放这个物品的最大值： if (j &lt; weight[i]) { // [i - 1]等于不放这个物品的重量 dp[i][j] = dp[i - 1][j]; } else { // 如果放进去：相当于容量为j - i的背包的dp值加上当前i的价值； int isPut = dp[i - 1][j - weight[i]] + value[i]; int noPut = dp[i - 1][j]; // 两种情况取最大值 dp[i][j] = Math.max(isPut, noPut); } } } System.out.println(dp[num - 1][vol]); System.out.println(Arrays.deepToString(dp)); } } class BagDemo1 { public static void main(String[] args) { int[] weight = {1, 3, 4}; int[] value = {15, 20, 30}; // 物品的数量 int num = weight.length; // 背包容量 int vol = 4; int[] dp = new int[vol + 1]; for (int i = 0; i &lt; num; i++) { // 从后向前，前面的数字不会受影响； for (int j = vol; j &gt;= weight[i]; j--) { dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); } System.out.println(Arrays.toString(dp)); } } } LeetCode题解 /** * 139. 单词拆分 */ // 自己写出来的复杂度比官方解答小，逻辑更细节一些，还是有点蒙 class Solution99 { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { String[] word = wordDict.toArray(new String[0]); char[] str = s.toCharArray(); boolean[] dp = new boolean[str.length + 1]; dp[0] = true; // 字符串组合是无序的，所以要遍历背包容量，再遍历物品 for (int j = 0; j &lt;= str.length; j++) { for (String w : word) { // 边界确实有点懵逼，left和right if (j &gt;= w.length() &amp;&amp; isTrue(str, w, j - w.length(), j)) dp[j] |= dp[j - w.length()]; } } return dp[str.length]; } public boolean isTrue(char[] str, String word, int left, int right) { int j = 0; for (int i = left; i &lt; right; i++, j++) { if (str[i] != word.charAt(j)) return false; } return true; } } /** * 279. 完全平方数 */ class Solution98 { public int numSquares(int n) { int[] dp = new int[n + 1]; Arrays.fill(dp, n + 1); dp[0] = 0; for (int i = 0; i * i &lt;= n; i++) { for (int j = i * i; j &lt;= n; j++) { dp[j] = Math.min(dp[j], dp[j - i * i] + 1); } } return dp[n]; } } /** * 322. 零钱兑换 */ class Solution97 { public int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; int maxValue = amount + 1; Arrays.fill(dp, maxValue); dp[0] = 0; for (int coin : coins) { for (int j = coin; j &lt;= amount; j++) { dp[j] = Math.min(dp[j], dp[j - coin] + 1); } } return dp[amount] != maxValue ? dp[amount] : -1; } } class Solution96 { public int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); dp[0] = 0; for (int j = 1; j &lt;= amount; j++) { for (int coin : coins) { if (j &gt;= coin) { dp[j] = Math.min(dp[j], dp[j - coin] + 1); } } } return dp[amount] &gt; amount ? dp[amount] : -1; } } /** * 70. 爬楼梯 (进阶) * 完全背包问题 * * @date 2021 11 15 */ class Solution95 { public int climbStairs(int n) { int[] value = new int[]{1, 2}; int[] dp = new int[n + 1]; dp[0] = 1; for (int i = 0; i &lt;= n; i++) { for (int v : value) { if (i &gt;= v) { dp[i] += dp[i - v]; } } } return dp[n]; } } /** * 377. 组合总和 Ⅳ * * @date 2021 11 14 */ class Solution94 { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target + 1]; dp[0] = 1; for (int j = 0; j &lt;= target; j++) { for (int num : nums) { if (num &lt;= j) { dp[j] += dp[j - num]; } } } return dp[target]; } } /** * 518. 零钱兑换 II */ class Solution93 { public int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; for (int coin : coins) { for (int j = coin; j &lt;= amount; j++) { dp[j] += dp[j - coin]; } } return dp[amount]; } } /** * 474. 一和零 */ // 二维背包问题，唉，懵逼 class Solution92 { public int findMaxForm(String[] strs, int m, int n) { int[][] dp = new int[m + 1][n + 1]; // 初始值，相当于什么都不拿，价值为0，可以忽略不写； for (String str : strs) { // 找出当前元素的0,1个数，相当于找出当前物品的质量 int sum0 = 0, sum1 = 0; for (char c : str.toCharArray()) { if (c == '0') { sum0++; } else sum1++; } // 二维背包的重量，两重for循环遍历取得最大值 for (int i = m; i &gt;= sum0; i--) { for (int j = n; j &gt;= sum1; j--) { // 当前物品的价值为一； dp[i][j] = Math.max(dp[i - sum0][j - sum1] + 1, dp[i][j]); } } } return dp[m][n]; } } /** * 494. 目标和 */ class Solution91 { public int findTargetSumWays(int[] nums, int target) { int sum = Arrays.stream(nums).sum(); if (Math.abs(target) &gt; sum || (sum + target) % 2 != 0) return 0; int vol = (sum + target) / 2; int[] dp = new int[vol + 1]; // dp的值代表着方法总数。初始值为1 dp[0] = 1; for (int num : nums) { for (int j = vol; j &gt;= num; j--) { dp[j] += dp[j - num]; } } return dp[vol]; } } /** * 1049. 最后一块石头的重量 II * 2021 11 13 */ // 使用boolean数组，速度更快 // dp[j] = true 此时的j即为能取到的最大值 class Solution90 { public int lastStoneWeightII(int[] stones) { int sum = Arrays.stream(stones).sum(); int vol = sum / 2; int[] dp = new int[vol + 1]; for (int stone : stones) { for (int j = vol; j &gt;= stone; j--) { dp[j] = Math.max(dp[j], dp[j - stone] + stone); } } return sum - dp[vol]; } } /** * 416. 分割等和子集 */ // 官方解答，使用boolean数组 class Solution89 { public boolean canPartition(int[] nums) { int n = nums.length; if (n &lt; 2) { return false; } int sum = 0, maxNum = 0; for (int num : nums) { sum += num; } if (sum % 2 != 0) { return false; } int target = sum / 2; boolean[] dp = new boolean[target + 1]; dp[0] = true; for (int num : nums) { for (int j = target; j &gt;= num; --j) { dp[j] |= dp[j - num]; } } return dp[target]; } } // 巧妙的转化成背包问题 class Solution88 { public boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) { sum += num; } if (sum % 2 != 0) { return false; } // 限定背包容量，所得的子集和只会小于等于sum / 2； int vol = sum / 2; int[] dp = new int[vol + 1]; for (int i = 0; i &lt; nums.length; i++) { for (int j = vol; j &gt;= nums[i]; j--) { dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]); } } return dp[vol] == vol; } } ","link":"https://shxiaj.github.io/post/java-BagProblem/"},{"title":"ChOx分析1-Rerun","content":"ChOx分析1-Rerun 一、Protein &amp; Surface 相互作用能 # 建立索引，表面组、蛋白组 gmx make_ndx -f ./md/md.tpr -n # 修改energy.mdp # qsub提及任务 gmx grompp -f energy.mdp -n -c ./nvt/nvt.gro -p topol.top -o ./energy/energy.tpr -po ./energy/energy.mdp gmx mdrun -v -rerun ./md/md.trr -deffnm ./energy/energy 二、Residue &amp; Surface 相互作用能 vmd获得接触残基 set aid [atomselect 0 {protein within 3.5 of {resname SDM SEM SAM SBM}}] $aid get resid $aid get resname 建索引 # VMD得到的结果填进去 rid=() rname=() flag=-1 # 重置这两变量 unset resid resname # 用于建索引 for (( i = 0; i &lt; ${#rid[@]}; i++ )); do if [ ${rid[$i]} -ne $flag ]; then flag=${rid[$i]} echo r ${rid[$i]} resid[${#resid[@]}]=r_${rid[$i]} resname[${#resname[@]}]=${rname[$i],,} fi done # 用于写mdp echo ${resid[@]} echo ${resname[@]^} # 用于python作图使用 for (( i = 0; i &lt; ${#resname[@]}; i++ )); do echo -e -n &quot;\\&quot;${resname[$i]^}${resid[$i]:2}\\&quot;, &quot; done &amp;&amp; echo # 将建索引输出的结果填进去，建立残基的索引 gmx make_ndx -f md/md.gro -n qsub提交任务 gmx grompp -f energy.mdp -n -c ./nvt/nvt.gro -p topol.top -o ./energy1/energy.tpr -po ./energy1/energy.mdp gmx mdrun -v -rerun ./md/md.trr -deffnm ./energy1/energy Col+Vdw能量处理 import numpy as np data = np.loadtxt('energy.xvg', dtype=float, usecols=(0, 1, 2), comments=['#', '@']) data = data[::2, ] totEne = np.add(data[:, 1], data[:, 2]) ene = np.insert(data, 3, values=totEne, axis=1) np.savetxt('ene.txt', ene, fmt='%15.5f', delimiter='') awk '!/^(#|@)/ {tot = $2 + $3; printf(&quot;%12f%14f%14f%14f\\n&quot;,$1,$2,$3,tot) }' energy.xvg &gt; ene.txt ","link":"https://shxiaj.github.io/post/chox1/"},{"title":"ChOx分析3-Python","content":"ChOx分析3-Python 一、偶极分布图 使用计算出来的'dipoles'文件，统计200ns后的结果 import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns plt.rc('font', family='Times New Roman') xy = np.loadtxt('dipoles', dtype=float, usecols=(0, 1)) ax = sns.histplot(data=xy[:, 1], stat='percent', bins=100, kde=True, color=&quot;white&quot;, kde_kws={&quot;cut&quot;: 200}, line_kws={&quot;linewidth&quot;: 1}, legend=True, fill=False, binrange=[-1, 1]) ax.lines[0].set_color('crimson') ax.set_xlim(-1, 1) ax.set_ylabel('percent %', fontsize=15) plt.show() 二、能量 rerun后的.edr文件 统计后100ns的平均作用能 一般用短程库伦作用能（Coul-SR）和短程范德华作用能（LJ-SR） gmx energy -s energy.tpr -f energy.edr -o energy.xvg 隔四个取一个,统计接触残基能量，蛋白质整体能量。 #!/usr/bin/env python3 import numpy as np import matplotlib.pyplot as plt plt.rc('font', family='Times New Roman') resname = [&quot;Gly30&quot;, &quot;Glu31&quot;, &quot;Ala32&quot;, &quot;Gly33&quot;, &quot;Asp145&quot;, &quot;Arg146&quot;, &quot;Arg150&quot;, &quot;Ser153&quot;, &quot;Lys163&quot;, &quot;Arg202&quot;, &quot;Glu207&quot;, &quot;Gly238&quot;, &quot;Thr239&quot;, &quot;Gly240&quot;, &quot;Lys241&quot;, &quot;Lys503&quot;] xy = np.loadtxt('energy1.xvg', dtype=float, comments=['#', '@']) ene = np.mean(xy[10000:, :], axis=0) # 库伦作用在前，vdw作用在后 temp1 = ene[1::2].copy() temp1[temp1 &gt; 0] = 0 temp2 = ene[1::2].copy() temp2[temp2 &lt; 0] = 0 temp3 = ene[2::2].copy() temp3[temp3 &gt; 0] = 0 temp4 = ene[2::2].copy() temp4[temp4 &lt; 0] = 0 plt.bar(resname, temp1, color=&quot;red&quot;, label=&quot;Coul&quot;) plt.bar(resname, temp2, color=&quot;red&quot;) # plt.bar(resname, ene[2::2], color=&quot;black&quot;, label=&quot;Vdw&quot;, bottom=ene[1::2]) # plt.bar(resname, ene[2::2], color=&quot;black&quot;, label=&quot;Vdw&quot;) plt.bar(resname, temp3, color=&quot;black&quot;, label=&quot;Vdw&quot;, bottom=temp1) plt.bar(resname, temp4, color=&quot;black&quot;, bottom=temp2) # plt.ylim(-160, -20) plt.xlabel('Times (ns)', fontsize=25) plt.ylabel('energy (kJ/mol)', fontsize=25) ax = plt.gca() ax.xaxis.set_ticks_position('top') # plt.gca().xaxis.set_ticks_position('top') plt.tick_params(top=False) plt.xticks(rotation=45) plt.xticks(fontsize=18) plt.yticks(fontsize=18) plt.legend(loc='best', frameon=False, fontsize=20) plt.show() 三、距离 gmx distance与gmx mindist gmx make_ndx -f md.tpr -n # 建立活性中心的索引组 echo -e &quot;a O6 O7 N6 N7 N9 C19 C17 C16 C15 \\n q&quot; | gmx make_ndx -f md.tpr -n echo -e &quot;a O6 O7 N6 N7 N9 \\n q&quot; | gmx make_ndx -f md.tpr -n # 结果更好 xmgrace ./rms/rmsd.xvg # 分析活性中心，蛋白质整体与表面最小距离 gmx mindist -s md.tpr -f md.xtc -tu ns -n -od -on gmx distance -s md.tpr -f md.xtc -oxyz -tu ns -n -select &quot;[0,0,1.519] plus group 28&quot; # 1.519 负电 gmx distance -s md.tpr -f md.xtc -oxyz -tu ns -n -select &quot;[0,0,1.632] plus group 30&quot; # 1.632 正电 四、RMSD &amp; RMSF &amp; 回旋半径 # 计算均方根偏差，选择蛋白质组 gmx rms -s md.tpr -f md.xtc -tu ns -n # 计算原子的均方根波动，选择蛋白质组 gmx rmsf -s md.tpr -f md.xtc -res -n -b 100000 # 计算回旋半径 gmx gyrate -s md.tpr -f md.xtc -n # 计算关于主轴的回旋半径 gmx gyrate -s md.tpr -f md.xtc -n -p # 两个结果总值相同，xyz分量的值不同 # 残基接触图 正电 gmx select -f md.xtc -s md.tpr -select 'resid 9 to 506 and z &lt; 1.982' -tu ns -dt 0.1 -seltype res_com -oi # 200-300ns残基接触比例 gmx select -f md.xtc -s md.tpr -select 'resid 9 to 506 and z &lt; 1.982' -tu ns -dt 0.05 -seltype res_com -oi -of -b 200 -e 300 # 残基接触图 负电 gmx select -f md.xtc -s md.tpr -select 'resid 9 to 506 and z &lt; 1.869' -tu ns -dt 0.1 -seltype res_com -oi # 200-300ns残基接触比例 gmx select -f md.xtc -s md.tpr -select 'resid 9 to 506 and z &lt; 1.869' -tu ns -seltype res_com -oi -of -b 200 -e 300 # 查看残基接触时间占比 awk '!/^(#|@)/ {if ($2 &gt; 0.8) printf(&quot;%7d%10.4f\\n&quot;,$1+8,$2)}' occupancy.xvg # 用作Origin画残基接触图 awk '{for(i=3;i&lt;=NF;i++) printf(&quot;%8.2f%6d\\n&quot;,$1/1000,$i)}' index.dat &gt; resOrigin # 输出蛋白质所有残基的id到index.dat gmx select -f md.gro -s md.tpr -select 'group protein' -oi -seltype res_com # 输出蛋白质端基序号 awk '{print $3 &quot; &quot; $NF}' index.dat # 输出蛋白质残基序号到resid, 用于gmx make_ndx输入 awk '{for(i=3;i&lt;=NF;++i) print $i; print &quot;q&quot;}' index.dat &gt; resid # 废弃 # for (( i = 9; i &lt;= 506; i++ )); do # echo r $i # done &gt; resid # echo q &gt;&gt; resid gmx make_ndx -f ../md.tpr -n &lt; resid seq 26 524 &gt; mindid gmx mindist -f md.xtc -s md.tpr -n -od -tu ns -b 200 -e 300 -dt 0.1 -ng 498 &lt; mindid ","link":"https://shxiaj.github.io/post/chox3/"},{"title":"Git提交到远程仓库","content":"我的电脑git提交命令 cd ~/Documents/Gridea/output # git init git add . git commit -m 'update' # git remote add origin git@github.com:ShXiaJ/shxiaj.github.io.git git push -u origin master bat脚本 gitPush.bat @echo off set path=D:\\Software\\PortableGit\\bin cd C:\\Users\\92306\\Documents\\Gridea\\output git add . git remote add github git@github.com:ShXiaJ/shxiaj.github.io.git git commit -m 'update1209' git push -u github master bash脚本 #!/usr/bin/bash cd C:/Users/92306/Documents/Gridea/output echo -e &quot;### 盛夏捷的静态博客\\nhttps://shxiaj.github.io 或 https://shxiaj.xyz&quot; &gt; README.md sed -i &quot;s|https://shxiaj.xyz|https://shxiaj.github.io|g&quot; `find . -name &quot;*.html&quot;` git add . git remote add github git@github.com:ShXiaJ/shxiaj.github.io.git git commit -m update$(date +%F) git push -u github master Git Cheat Sheet 中文版教程 索引 配置 配置文件 创建 本地修改 搜索 提交历史 分支与标签 更新与发布 合并与重置 撤销 Git Flow 配置 列出当前配置： $ git config --list 列出repository配置： $ git config --local --list 列出全局配置： $ git config --global --list 列出系统配置： $ git config --system --list 设置用户名： $ git config --global user.name “[firstname lastname]” 设置用户邮箱： $ git config --global user.email “[valid-email]” 设置git命令输出为彩色： $ git config --global color.ui auto 设置git使用的文本编辑器设： $ git config --global core.editor vi 配置文件 Repository配置对应的配置文件路径[--local]： &lt;repo&gt;/.git/config 用户全局配置对应的配置文件路径[--global]： ~/.gitconfig 系统配置对应的配置文件路径[--local]： /etc/gitconfig 创建 复制一个已创建的仓库: # 通过 SSH $ git clone ssh://user@domain.com/repo.git #通过 HTTP $ git clone http://domain.com/user/repo.git 创建一个新的本地仓库: $ git init 本地修改 显示工作路径下已修改的文件： $ git status 显示与上次提交版本文件的不同： $ git diff 把当前所有修改添加到下次提交中： $ git add . 把对某个文件的修改添加到下次提交中： $ git add -p &lt;file&gt; 提交本地的所有修改： $ git commit -a 提交之前已标记的变化： $ git commit 附加消息提交： $ git commit -m 'message here' 提交，并将提交时间设置为之前的某个日期: git commit --date=&quot;`date --date='n day ago'`&quot; -am &quot;Commit Message&quot; 修改上次提交 请勿修改已发布的提交记录! $ git commit --amend 修改上次提交的committer date： GIT_COMMITTER_DATE=&quot;date&quot; git commit --amend 修改上次提交的author date： git commit --amend --date=&quot;date&quot; 把当前分支中未提交的修改移动到其他分支： git stash git checkout branch2 git stash pop 将 stashed changes 应用到当前分支： git stash apply 删除最新一次的 stashed changes： git stash drop 搜索 从当前目录的所有文件中查找文本内容： $ git grep &quot;Hello&quot; 在某一版本中搜索文本： $ git grep &quot;Hello&quot; v2.5 提交历史 从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）： $ git log 显示所有提交（仅显示提交的hash和message）： $ git log --oneline 显示某个用户的所有提交： $ git log --author=&quot;username&quot; 显示某个文件的所有修改： $ git log -p &lt;file&gt; 仅显示远端&lt;remote/master&gt;分支与远端&lt;origin/master&gt;分支提交记录的差集： $ git log --oneline &lt;origin/master&gt;..&lt;remote/master&gt; --left-right 谁，在什么时间，修改了文件的什么内容： $ git blame &lt;file&gt; 显示reflog： $ git reflog show 删除reflog： $ git reflog delete 分支与标签 列出所有的分支： $ git branch 列出所有的远端分支： $ git branch -r 切换分支： $ git checkout &lt;branch&gt; 创建并切换到新分支: $ git checkout -b &lt;branch&gt; 基于当前分支创建新分支： $ git branch &lt;new-branch&gt; 基于远程分支创建新的可追溯的分支： $ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt; 删除本地分支: $ git branch -d &lt;branch&gt; 强制删除一个本地分支： 将会丢失未合并的修改！ $ git branch -D &lt;branch&gt; 给当前版本打标签： $ git tag &lt;tag-name&gt; 给当前版本打标签并附加消息： $ git tag -a &lt;tag-name&gt; 更新与发布 列出当前配置的远程端： $ git remote -v 显示远程端的信息： $ git remote show &lt;remote&gt; 添加新的远程端： $ git remote add &lt;remote&gt; &lt;url&gt; 下载远程端版本，但不合并到HEAD中： $ git fetch &lt;remote&gt; 下载远程端版本，并自动与HEAD版本合并： $ git remote pull &lt;remote&gt; &lt;url&gt; 将远程端版本合并到本地版本中： $ git pull origin master 以rebase方式将远端分支与本地合并： git pull --rebase &lt;remote&gt; &lt;branch&gt; 将本地版本发布到远程端： $ git push remote &lt;remote&gt; &lt;branch&gt; 删除远程端分支： $ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0) or git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0) 发布标签: $ git push --tags ###合并与重置(Rebase) 将分支合并到当前HEAD中： $ git merge &lt;branch&gt; 将当前HEAD版本重置到分支中: 请勿重置已发布的提交! $ git rebase &lt;branch&gt; 退出重置: $ git rebase --abort 解决冲突后继续重置： $ git rebase --continue 使用配置好的merge tool 解决冲突： $ git mergetool 在编辑器中手动解决冲突后，标记文件为已解决冲突： $ git add &lt;resolved-file&gt; $ git rm &lt;resolved-file&gt; 合并提交： $ git rebase -i &lt;commit-just-before-first&gt; 把上面的内容替换为下面的内容： 原内容： pick &lt;commit_id&gt; pick &lt;commit_id2&gt; pick &lt;commit_id3&gt; 替换为： pick &lt;commit_id&gt; squash &lt;commit_id2&gt; squash &lt;commit_id3&gt; 撤销 放弃工作目录下的所有修改： $ git reset --hard HEAD 移除缓存区的所有文件（i.e. 撤销上次git add）: $ git reset HEAD 放弃某个文件的所有本地修改： $ git checkout HEAD &lt;file&gt; 重置一个提交（通过创建一个截然不同的新提交） $ git revert &lt;commit&gt; 将HEAD重置到指定的版本，并抛弃该版本之后的所有修改： $ git reset --hard &lt;commit&gt; 用远端分支强制覆盖本地分支： git reset --hard &lt;remote/branch&gt; e.g., upstream/master, origin/my-feature 将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改： $ git reset &lt;commit&gt; 将HEAD重置到上一次提交的版本，并保留未提交的本地修改： $ git reset --keep &lt;commit&gt; 删除添加.gitignore文件前错误提交的文件： $ git rm -r --cached . $ git add . $ git commit -m &quot;remove xyz file&quot; Git-Flow 索引 安装 开始 特性 做一个release版本 紧急修复 Commands 安装 你需要有一个可以工作的 git 作为前提。 Git flow 可以工作在 OSX, Linux 和 Windows之下 OSX Homebrew: $ brew install git-flow OSX Macports: $ port install git-flow Linux: $ apt-get install git-flow Windows (Cygwin): 安装 git-flow, 你需要 wget 和 util-linux。 $ wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash 开始 为了自定义你的项目，Git flow 需要初始化过程。 使用 git-flow，从初始化一个现有的 git 库内开始。 初始化，你必须回答几个关于分支的命名约定的问题。建议使用默认值。 git flow init 特性 为即将发布的版本开发新功能特性。 这通常只存在开发者的库中。 创建一个新特性: 下面操作创建了一个新的feature分支，并切换到该分支 git flow feature start MYFEATURE 完成新特性的开发: 完成开发新特性。这个动作执行下面的操作： 合并 MYFEATURE 分支到 'develop' 删除这个新特性分支 切换回 'develop' 分支 git flow feature finish MYFEATURE 发布新特性: 你是否合作开发一项新特性？ 发布新特性分支到远程服务器，所以，其它用户也可以使用这分支。 git flow feature publish MYFEATURE 取得一个发布的新特性分支: 取得其它用户发布的新特性分支。 git flow feature pull origin MYFEATURE 追溯远端上的特性: 通过下面命令追溯远端上的特性 git flow feature track MYFEATURE 做一个release版本 支持一个新的用于生产环境的发布版本。 允许修正小问题，并为发布版本准备元数据。 开始创建release版本: 开始创建release版本，使用 git flow release 命令。 'release' 分支的创建基于 'develop' 分支。 你可以选择提供一个 [BASE]参数，即提交记录的 sha-1 hash 值，来开启动 release 分支。 这个提交记录的 sha-1 hash 值必须是'develop' 分支下的。 git flow release start RELEASE [BASE] 创建 release 分支之后立即发布允许其它用户向这个 release 分支提交内容是个明智的做法。命令十分类似发布新特性： git flow release publish RELEASE (你可以通过 git flow release track RELEASE 命令追溯远端的 release 版本) 完成 release 版本: 完成 release 版本是一个大 git 分支操作。它执行下面几个动作： 归并 release 分支到 'master' 分支。 用 release 分支名打 Tag 归并 release 分支到 'develop' 移除 release 分支。 git flow release finish RELEASE 不要忘记使用git push --tags将tags推送到远端 紧急修复 紧急修复来自这样的需求：生产环境的版本处于一个不预期状态，需要立即修正。有可能是需要修正 master 分支上某个 TAG 标记的生产版本。 开始 git flow 紧急修复: 像其它 git flow 命令一样, 紧急修复分支开始自： $ git flow hotfix start VERSION [BASENAME] VERSION 参数标记着修正版本。你可以从 [BASENAME]开始，[BASENAME]`为finish release时填写的版本号 完成紧急修复: 当完成紧急修复分支，代码归并回 develop 和 master 分支。相应地，master 分支打上修正版本的 TAG。 git flow hotfix finish VERSION ","link":"https://shxiaj.github.io/post/git-user/"},{"title":"Java二叉树算法题解 LeetCode","content":" 1.Note 二叉树的定义 class TreeNode { int val; TreeNode left; TreeNode right; public TreeNode() { } public TreeNode(int val) { this.val = val; } public TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } 平衡二叉树： 一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。 搜索二叉树： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 完全二叉树： 叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。 深度优先搜索 depth first search dfs 广度优先搜索 breadth first search bfs 二叉树教程 2. LeetCode题目 package leetcode; import java.util.*; public class TreeDemo { public static void main(String[] args) { System.out.println(Long.MAX_VALUE); System.out.println(Long.MIN_VALUE); System.out.println(Integer.MAX_VALUE); System.out.println(Integer.MIN_VALUE); } } /** * 538. 把二叉搜索树转换为累加树 */ class Solution39 { int sum = 0; public TreeNode convertBST(TreeNode root) { dfsPostorder(root); return root; } public void dfsPostorder(TreeNode root) { if (root == null) return; dfsPostorder(root.right); sum += root.val; root.val = sum; dfsPostorder(root.left); } } /** * 108. 将有序数组转换为二叉搜索树 */ // 二分法，平均分，高度差不可能大于1，我竟然能瞎写出来，瞎蒙 class Solution38 { public TreeNode sortedArrayToBST(int[] nums) { TreeNode root = dfsBuild(nums, 0, nums.length - 1); return root; } public TreeNode dfsBuild(int[] nums, int l, int r) { if (l &gt; r) return null; int curIndex = (l - r) / 2 + r; TreeNode node = new TreeNode(nums[curIndex]); node.left = dfsBuild(nums, l, curIndex - 1); node.right = dfsBuild(nums, curIndex + 1, r); return node; } } /** * @date 2021 10 27 * 450. 删除二叉搜索树中的节点 */ class Solution37 { public TreeNode deleteNode(TreeNode root, int key) { if (root == null) return null; if (key &lt; root.val) { root.left = deleteNode(root.left, key); } else if (key &gt; root.val) { root.right = deleteNode(root.right, key); } else { if (root.left == null) { return root.right; } else if (root.right == null) { return root.left; } else { TreeNode cur = root.right; while (cur.left != null) { cur = cur.left; } cur.left = root.left; return root.right; } } return root; } } /** * 701.二叉搜索树中的插入操作 */ class Solution36 { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode node = root; while (node != null) { if (node.val &gt; val) { if (node.left == null) { node.left = new TreeNode(val); break; } else { node = node.left; } } else { if (node.right == null) { node.right = new TreeNode(val); break; } else { node = node.right; } } } return root; } } class Solution35 { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } if (root.val &gt; val) { root.left = insertIntoBST(root.left, val); } else { root.right = insertIntoBST(root.right, val); } return root; } } /** * @date 2021 10 26 * 235. 二叉搜索树的最近公共祖先 */ class Solution34 { // 左右子树的公共祖先是唯一的 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { while (true) { if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) { root = root.left; } else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) { root = root.right; } else { return root; } } } } /** * 236. 二叉树的最近公共祖先 */ class Solution33 { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { // 找到p、q节点或者为null时，返回root if (root == null || root == p || root == q) return root; // 找左子树是否包含p、q，如果有则left == q或者p； TreeNode left = lowestCommonAncestor(root.left, p, q); // 同上 TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;&amp; right != null) { //找到公共祖先节点 return root; // 返回值即为公共节点，祖先的父节点的另一侧必定为null， // 会一直返回公共祖先的值直到最上层 } else if (left != null) { // 左树有节点、右树无节点，返回左树 return left; } else { return right; } } } class Solution32 { private TreeNode answer = null; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root, p, q); return this.answer; } public boolean dfs(TreeNode root, TreeNode p, TreeNode q) { if (root == null) return false; boolean left = dfs(root.left, p, q); boolean right = dfs(root.right, p, q); if ((left &amp;&amp; right) || ((root == p || root == q) &amp;&amp; (left || right))) { answer = root; } // 重点，我也不知道如何解释；当找到公共祖先后，祖先的父节点的另一侧必定为false， // 不可能满足上面if判断，answer不可能被重新赋值 return left || right || root == p || root == q; } } /** * @date 2021 10 25 * 501.二叉搜索树中的众数 */ class Solution31 { List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); int base = 0; int count = 0; int maxCount = 0; public int[] findMode(TreeNode root) { dfs(root); int[] resultArray = new int[ret.size()]; for (int i = 0; i &lt; ret.size(); i++) { resultArray[i] = ret.get(i); } return resultArray; } public void dfs(TreeNode root) { if (root == null) return; dfs(root.left); update(root.val); dfs(root.right); } public void update(int value) { if (base == value) { count++; } else { count = 1; base = value; } if (count == maxCount) { ret.add(value); } else if (count &gt; maxCount) { maxCount = count; ret.clear(); ret.add(value); } } } class Solution30 { Map&lt;Integer, Integer&gt; frequency = new HashMap&lt;&gt;(); public int[] findMode(TreeNode root) { inOrderTraverse(root); int maxFreq = Integer.MIN_VALUE; for (int i : frequency.keySet()) { if (maxFreq &lt; frequency.get(i)) { maxFreq = frequency.get(i); } } List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); for (int i : frequency.keySet()) { if (maxFreq == frequency.get(i)) { ret.add(i); } } int[] res = new int[ret.size()]; for (int i = 0; i &lt; res.length; i++) { res[i] = ret.get(i); } return res; } public void inOrderTraverse(TreeNode root) { if (root == null) return; inOrderTraverse(root.left); frequency.put(root.val, frequency.getOrDefault(root.val, 0) + 1); inOrderTraverse(root.right); } } /** * 530. 二叉搜索树的最小绝对差 */ class Solution29 { public int getMinimumDifference(TreeNode root) { List&lt;Integer&gt; val = new ArrayList&lt;&gt;(); inOrder(root, val); int min = val.get(1) - val.get(0); for (int i = 1; i &lt; val.size() - 1; i++) { if (val.get(i + 1) - val.get(i) &lt; min) { min = val.get(i + 1) - val.get(i); } } return min; } public void inOrder(TreeNode root, List&lt;Integer&gt; ret) { if (root == null) return; inOrder(root.left, ret); ret.add(root.val); inOrder(root.right, ret); } } /** * 98. 验证二叉搜索树 */ class Solution28 { public boolean isValidBST(TreeNode root) { return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE); } public boolean isValidBST(TreeNode root, int lower, int upper) { if (root == null) return true; if (root.val &lt;= lower || root.val &gt;= upper) { return false; } return isValidBST(root.left, lower, root.val) &amp;&amp; isValidBST(root.right, root.val, upper); } } /** * 700. 二叉搜索树中的搜索 */ class Solution27 { public TreeNode searchBST(TreeNode root, int val) { if (root == null || root.val == val) return root; TreeNode node = null; if (root.val &gt; val) { node = searchBST(root.left, val); } else { node = searchBST(root.right, val); } return node; } } /** * 617. 合并二叉树 */ class Solution26 { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) return root2; if (root2 == null) return root1; TreeNode node = null; node = new TreeNode(root1.val + root2.val); node.left = mergeTrees(root1.left, root2.left); node.right = mergeTrees(root1.right, root2.right); return node; } } /** * 654. 最大二叉树 */ class Solution25 { public TreeNode constructMaximumBinaryTree(int[] nums) { if (nums.length &lt;= 0) return null; int maxI[] = getMaxIndex(nums); TreeNode node = new TreeNode(maxI[0]); int[] left = Arrays.copyOfRange(nums, 0, maxI[1]); int[] right = Arrays.copyOfRange(nums, maxI[1] + 1, nums.length); node.left = constructMaximumBinaryTree(left); node.right = constructMaximumBinaryTree(right); return node; } public int[] getMaxIndex(int[] nums) { int max = nums[0]; int index = 0; for (int i = 0; i &lt; nums.length; i++) { if (max &lt; nums[i]) { index = i; max = nums[i]; } } return new int[]{max, index}; } } /** * 106. 从中序与后序遍历序列构造二叉树 */ class Solution24 { Map&lt;Integer, Integer&gt; memo = new HashMap&lt;&gt;(); int[] post; public TreeNode buildTree(int[] inorder, int[] postorder) { for (int i = 0; i &lt; inorder.length; i++) { this.memo.put(inorder[i], i); } // 将值赋予全局变量，方便递归处理 this.post = postorder; TreeNode root = buildTree(0, inorder.length - 1, 0, postorder.length - 1); return root; } // 中序和后序的始末位置索引 public TreeNode buildTree(int inStart, int inEnd, int poStart, int poEnd) { // 如果数量为空，直接返回; // 如果相等，那还要把当前值生成一个对象，所以必须是 start &gt; end; if (inStart &gt; inEnd || poStart &gt; poEnd) { return null; } // 找到根节点，并且找到中序的根节点的索引; int curRoot = post[poEnd]; int curRootIndex = this.memo.get(curRoot); //中序的索引; // 创建新的节点对象，将当前的值赋予node; TreeNode node = new TreeNode(curRoot); node.left = buildTree(inStart, curRootIndex - 1, poStart, poStart + curRootIndex - inStart - 1); node.right = buildTree(curRootIndex + 1, inEnd, poStart + curRootIndex - inStart, poEnd - 1); return node; } } /** * 113. 路径总和ii */ class Solution23 { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) { findSum(root, targetSum); return ret; } public void findSum(TreeNode root, int target) { if (root == null) return; path.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; target == root.val) { ret.add(new ArrayList&lt;&gt;(path)); //添加新的对象，否则列表一直引用的是同一个path对象； } findSum(root.left, target - root.val); findSum(root.right, target - root.val); path.remove(path.size() - 1); //回溯 } } /** * 112. 路径总和 */ class Solution22 { // targetSum - root.val精髓所在 public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) return false; if (root.right == null &amp;&amp; root.left == null) { return targetSum == root.val; } boolean l = hasPathSum(root.left, targetSum - root.val); boolean r = hasPathSum(root.right, targetSum - root.val); return l || r; } public boolean pathSum(TreeNode root, int sum, int target) { sum += root.val; if (root.right == null &amp;&amp; root.left == null &amp;&amp; sum == target) { return true; } boolean l = false; boolean r = false; if (root.left != null) { l = pathSum(root.left, sum, target); } if (root.right != null) { r = pathSum(root.right, sum, target); } return l || r; } } /** * 513. 找树左下角的值 */ class Solution21 { private int maxLevel = 0; private int value = 0; public int findBottomLeftValue(TreeNode root) { value = root.val; findLeftValue(root, 0); return value; } public void findLeftValue(TreeNode root, int level) { if (root == null) return; if (root.right == null &amp;&amp; root.left == null) { if (level &gt; maxLevel) { maxLevel = level; value = root.val; } return; } findLeftValue(root.left, level + 1); findLeftValue(root.right, level + 1); } } class Solution20 { public int findBottomLeftValue(TreeNode root) { int maxLevel = 0; int value = 0; Queue&lt;TreeNode&gt; levelNode = new LinkedList&lt;&gt;(); levelNode.offer(root); while (!levelNode.isEmpty()) { int size = levelNode.size(); TreeNode node = levelNode.peek(); value = node.val; for (int i = 0; i &lt; size; i++) { node = levelNode.poll(); if (node.left != null) levelNode.offer(node.left); if (node.right != null) levelNode.offer(node.right); } } return value; } } /** * 404. 左叶子之和 */ class Solution19 { public int sumOfLeftLeaves(TreeNode root) { if (root == null) return 0; int sum = 0; if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) { sum += root.left.val; } sum += sumOfLeftLeaves(root.left); sum += sumOfLeftLeaves(root.right); return sum; } } /** * 257. 二叉树的所有路径 */ class Solution18 { public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; paths = new ArrayList&lt;&gt;(); constructPath(root, &quot;&quot;, paths); return paths; } public void constructPath(TreeNode root, String path, List&lt;String&gt; paths) { if (root != null) { StringBuilder pathSB = new StringBuilder(path); pathSB.append(Integer.toString(root.val)); if (root.left == null &amp;&amp; root.right == null) { //当前为叶子点 paths.add(pathSB.toString()); } else { pathSB.append(&quot;-&gt;&quot;); constructPath(root.left, pathSB.toString(), paths); constructPath(root.right, pathSB.toString(), paths); } } } } /** * 110. 平衡二叉树 */ class Solution17 { public boolean isBalanced(TreeNode root) { if (root == null) return true; return depth(root) &gt;= 0; } public int depth(TreeNode root) { if (root == null) return 0; int l = depth(root.left); int r = depth(root.right); if (Math.abs(l - r) &gt; 1 || l == -1 || r == -1) { return -1; } else { // 返回子树的高度，用于下一层迭代的比较！靠终于懂了 return Math.max(r, l) + 1; } } } /** * 222. 完全二叉树的节点个数 */ class Solution16 { public int countNodes(TreeNode root) { if (root == null) return 0; int sum = 0; sum++; sum += countNodes(root.left); sum += countNodes(root.right); return sum; } } /** * 104. 二叉树的最大深度 */ class Solution15 { public int maxDepth(Node root) { if (root == null) return 0; List&lt;Integer&gt; depth = new ArrayList&lt;&gt;(); for (Node child : root.children) { depth.add(maxDepth(child)); } if (depth.isEmpty()) return 1; return Collections.max(depth) + 1; } } /** * 101. 对称二叉树 */ class Solution14 { public boolean isSymmetric(TreeNode root) { if (root == null) return false; return check(root.left, root.right); } public boolean check(TreeNode left, TreeNode right) { if (left == null &amp;&amp; right == null) { return true; } else if (left == null || right == null) { return false; } else { if (left.val == right.val &amp;&amp; check(left.left, right.right) &amp;&amp; check(left.right, right.left)) { return true; } return false; } } } /** * 226. 翻转二叉树 */ class Solution13 { public TreeNode invertTree(TreeNode root) { if (root == null) return null; TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.right = left; root.left = right; return root; } } /** * 104. 二叉树的最大深度 */ class Solution12 { public int maxDepth(TreeNode root) { if (root == null) return 0; int maxDepth = 0; Queue&lt;TreeNode&gt; levelNode = new LinkedList&lt;&gt;(); levelNode.offer(root); while (!levelNode.isEmpty()) { int size = levelNode.size(); for (int i = 0; i &lt; size; i++) { TreeNode node = levelNode.poll(); if (node.left != null) levelNode.offer(node.left); if (node.right != null) levelNode.offer(node.right); } maxDepth++; } return maxDepth; } } /** * 116. 填充每个节点的下一个右侧节点指针 */ //class Solution11 { // public Node connect(Node root) { // if (root == null) return null; // // Queue&lt;Node&gt; levelNode = new LinkedList&lt;&gt;(); // levelNode.offer(root); // // while (!levelNode.isEmpty()) { // int size = levelNode.size(); // // for (int i = 0; i &lt; size; i++) { // Node node = levelNode.poll(); // if (i != size - 1) { // node.next = levelNode.peek(); // } else { // node.next = null; // } // if (node.left != null) levelNode.offer(node.left); // if (node.right != null) levelNode.offer(node.right); // } // } // // // return root; // } //} /** * 515: 每个树行中找到层最大值 */ class Solution10 { public List&lt;Integer&gt; largestValues(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Queue&lt;TreeNode&gt; levelNode = new LinkedList&lt;&gt;(); levelNode.offer(root); while (!levelNode.isEmpty()) { int levelSize = levelNode.size(); int maxVal = Integer.MIN_VALUE; for (int i = 0; i &lt; levelSize; i++) { TreeNode node = levelNode.poll(); maxVal = Math.max(maxVal, node.val); if (node.left != null) levelNode.offer(node.left); if (node.right != null) levelNode.offer(node.right); } result.add(maxVal); } return result; } } /** * 429题：N叉树的层序遍历 */ // Definition for a Node. class Node { public int val; public List&lt;Node&gt; children; public Node() { } public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; } }; class Solution9 { public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) return result; Queue&lt;Node&gt; levelNode = new LinkedList&lt;&gt;(); levelNode.offer(root); while (!levelNode.isEmpty()) { int levelSize = levelNode.size(); List&lt;Integer&gt; levelValue = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; levelSize; i++) { Node node = levelNode.poll(); levelValue.add(node.val); levelNode.addAll(node.children); // 等价于下面的for循环；forEach循环是否要判断null？ // int childSize = node.children.size(); // for (int j = 0; j &lt; childSize; j++) { // levelNode.offer(node.children.get(j)); // } } result.add(levelValue); } return result; } } /** * 637题：二叉树的层平均值、深度优先搜索 */ class Solution8 { public List&lt;Double&gt; averageOfLevels(TreeNode root) { List&lt;Double&gt; average = new ArrayList&lt;&gt;(); if (root == null) { return average; } Deque&lt;TreeNode&gt; nodeStack = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; depthStack = new LinkedList&lt;&gt;(); nodeStack.push(root); depthStack.push(0); List&lt;Integer&gt; count = new ArrayList&lt;&gt;(); Map&lt;Integer, Double&gt; levelAndSum = new HashMap&lt;&gt;(); while (!nodeStack.isEmpty()) { TreeNode node = nodeStack.pop(); int depth = depthStack.pop(); if (node != null) { if (depth &lt; count.size()) { count.set(depth, count.get(depth) + 1); } else { count.add(1); } // 设置Map的默认值 levelAndSum.put(depth, levelAndSum.getOrDefault(depth, 0.0) + node.val); nodeStack.push(node.left); depthStack.push(depth + 1); nodeStack.push(node.right); depthStack.push(depth + 1); } } for (Integer integer : levelAndSum.keySet()) { System.out.println(integer); average.add(levelAndSum.get(integer) / count.get(integer)); } return average; } } /** * 637题：二叉树的层平均值 */ class Solution6 { public List&lt;Double&gt; averageOfLevels(TreeNode root) { List&lt;Double&gt; result = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); Double sum = 0.0; // List&lt;Double&gt; levelAverage = new ArrayList&lt;&gt;(); TreeNode node = null; for (int i = 0; i &lt; levelSize; i++) { node = queue.poll(); // levelAverage.add((double) node.val); sum += node.val; if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } result.add(sum / levelSize); } return result; } } /** * 199题：二叉树的右视图 */ class Solution7 { public List&lt;Integer&gt; rightSideView(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Map&lt;Integer, Integer&gt; rightMostValueDepth = new HashMap&lt;&gt;(); Deque&lt;TreeNode&gt; nodeStack = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; depthStack = new LinkedList&lt;&gt;(); nodeStack.push(root); depthStack.push(0); while (!nodeStack.isEmpty()) { TreeNode node = nodeStack.pop(); int depth = depthStack.pop(); if (node != null) { if (!rightMostValueDepth.containsKey(depth)) { rightMostValueDepth.put(depth, node.val); } nodeStack.push(node.left); depthStack.push(depth + 1); nodeStack.push(node.right); depthStack.push(depth + 1); } } // 学到了，直接addALL全部加进去，牛啊 result.addAll(rightMostValueDepth.values()); return result; } } class Solution5 { public List&lt;Integer&gt; rightSideView(TreeNode root) { //存放结果的List表，用的ArrayList List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; //队列，用的LinkedList Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) { // 层数节点值 int levelSize = queue.size(); TreeNode node = null; for (int i = 0; i &lt; levelSize; i++) { node = queue.poll(); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } result.add(node.val); } return result; } } class Solution4 { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) { return result; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()) { List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); int currentLevelSize = queue.size(); for (int i = 0; i &lt; currentLevelSize; i++) { TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } result.add(level); } Collections.reverse(result); return result; } } /** * 前中后序遍历 * 递归 */ class Solution1 { List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); preRecursion(root, result); return result; } void preRecursion(TreeNode node, List&lt;Integer&gt; result) { if (node == null) return; // 前中后序遍历递归方法差不多 result.add(node.val); preRecursion(node.left, result); preRecursion(node.right, result); } } /** * 迭代方法； */ class Solution2 { List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if (root == null) return result; Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;(); TreeNode node = root; // // 模拟栈的迭代，前序 // while (!stack.isEmpty() || node != null) { // while (node != null) { // result.add(node.val); // stack.push(node); // node = node.left; // } // stack.pop(); // node = node.right; // } // // 模拟栈的迭代，中序 // while (!stack.isEmpty() || node != null) { // while (node != null) { // stack.push(node); // node = node.left; // } // stack.pop(); // result.add(node.val); // node = node.right; // } // // 模拟栈的迭代，后序，左右中 // TreeNode prev = null; // // while (!stack.isEmpty() || node != null) { // while (node != null) { // stack.push(node); // node = node.left; // } // node = stack.pop(); // if (node.right != null &amp;&amp; root.right != prev) { // stack.push(node); // node = node.right; // } else { // result.add(node.val); // prev = node; // node = null; // } // // } return result; } } class TreeNode { int val; TreeNode left; TreeNode right; public TreeNode() { } public TreeNode(int val) { this.val = val; } public TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } ","link":"https://shxiaj.github.io/post/java-TreeNode/"},{"title":"ChOx分析2-VMD","content":"ChOx分析2-VMD 一、处理trr轨迹文件 防止蛋白质分子裂开，帧总数为1/3，提取最后一帧gro文件 # -skip 间隔帧数输出 echo 0 | gmx trjconv -s md.tpr -f md.trr -o md.xtc -pbc mol -ur compact -skip 2 # 提取最后一帧，不带水分子 echo 20 | gmx trjconv -s md.tpr -f md.xtc -o md.gro -dump 300000 二、xtc中导出dipoles # 建立索引，将蛋白质、FAD索引合并，否则分子不完整 echo -e &quot;1 | 13\\nq\\n&quot; | gmx make_ndx -f ./md.tpr -n # gmx dipoles计算静电偶极、是物理意义 echo 28 | gmx dipoles -s md.tpr -f md.xtc -n # 计算偶极与Z轴的夹角的余弦值，写入dipoles awk '!/^(#|@)/ {theta = $4 / $5; print $1 &quot; &quot; theta}' Mtot.xvg &gt; dipoles.txt 三、VMD画偶极 1. 蛋白质分子质心坐标 打开md.gro， 蛋白质居中（自定义命令pc）见附录，然后保存再打开 重新打开后输入tcl命令 ## VMD获取质心坐标， mass_center_x mass_center_y mass_center_z set mcid [atomselect 0 &quot;protein or resname FAD&quot;] measure center $mcid weight mass 2. 直接用脚本画，缩放目标可能需要调整，文件名：dipoles.sh 脚本目录：${HOME}/sx/script/dipoles.sh 用法./dipoles.sh mass_center_x mass_center_y mass_center_z 脚本内容：附录 3. VMD 中画偶极 使用脚本输出的vmd命令直接画 display resetview rotate x by -90 rotate y by -90 source {E:\\Notes\\Script\\VMD\\color.tcl} draw delete all draw color purple # 下面两条命令替换成脚本得到的 draw cylinder {41.048 34.253 47.490} {56.475 62.396 17.579} radius 0.5 filled yes resolution 20 draw cone {56.475 62.396 17.579} {58.058 65.282 14.511} radius 1.5 resolution 20 4. VMD 保存图片 调整一下视角，背景白色，二级结构，设置好工作目录，渲染保存 缩放vmd视图看起来是透视，但是渲染出来的是正常的 # 缩放 scale by 1.00 # 关闭坐标轴 axes location Off # 背景白色 bw # 关闭景深 display depthcue off # 开灯 light 2 on # render文件 render Tachyon vmdscene.dat # 渲染 tachyon_WIN32.exe vmdscene.dat -aasamples 24 -format BMP -mediumshade -trans_vmd -res 2560 1440 -numthreads 4 -o dipole.bmp render Tachyon vmdscene.dat set fileName [clock seconds] tachyon_WIN32.exe vmdscene.dat -aasamples 24 -format BMP -mediumshade -trans_vmd -res 1200 1200 -numthreads 8 -o ${fileName}.bmp tachyon_WIN32.exe我自己已经写到环境变量，可直接调用 5.PTMC的偶极 设置盒子大小10 10 10 pbc wrap -center com -centersel &quot;serial 1 to 498&quot; -compound residue -all set mcid [atomselect 0 &quot;serial 1 to 498&quot;] measure center $mcid weight mass 附vmd初始化脚本：vmd.rc display projection orthographic proc bw {} {color Display Background white} proc bb {} {color Display Background black} proc bx {} {pbc box} proc sam {} { display resetview rotate x by -90 rotate y by -90 mol delrep 0 0 mol modcolor 0 0 Structure mol modstyle 0 0 NewCartoon 0.300000 10.000000 4.100000 0 mol color Structure mol representation NewCartoon 0.300000 10.000000 4.100000 0 mol selection not water mol material Glossy mol addrep 0 mol modselect 1 0 {resname SAM SBM SEM SDM} mol color Name mol representation Lines 1.000000 mol selection {resname SAM SBM SEM SDM} mol material Glossy mol addrep 0 mol modselect 2 0 resname FAD mol modcolor 2 0 ColorID 0 mol modcolor 2 0 ColorID 7 mol modstyle 2 0 VDW 1.000000 12.000000 mol color ColorID 7 mol representation VDW 1.000000 12.000000 mol selection resname FAD mol material Glossy mol modrep 2 0 mol addrep 0 } proc pc {} { pbc wrap -center com -centersel &quot;protein&quot; -compound residue -all } 附Script: dipoles.sh # Usage: 需要Mtot.xvg、 md.gro (都为最后一帧) # Author: Ding ######################################################### function fun1 { # 获取偶极xyz分量 awk 'END {printf(&quot;%15.3f%15.3f%15.3f\\n&quot;,$2,$3,$4)}' Mtot.xvg } function fun2 { # md.gro 最后一行的残基编号和原子总数 awk 'BEGIN {FIELDWIDTHS=&quot;5 3 7 5&quot;} \\ {a=aa;b=bb;aa=$1;bb=$4;} END {print a &quot; &quot; b}' md.gro } function fun3 { # 缩放的坐标，质心、偶极、尖尖 awk 'BEGIN { mx = &quot;'$mx'&quot; / 10 ; my = &quot;'${my}'&quot; / 10; mz = &quot;'${mz}'&quot; / 10; dx = &quot;'${dip[0]}'&quot;; dy = &quot;'${dip[1]}'&quot;; dz = &quot;'${dip[2]}'&quot;; s = 3; t = 8; for (i = 1; i &lt; 200; ++i) { dxi=dx/i; dyi=dy/i; dzi=dz/i; if (-s &lt; dxi &amp;&amp; dxi &lt; s &amp;&amp; -s &lt; dyi &amp;&amp; dyi &lt; s &amp;&amp; -s &lt; dzi &amp;&amp; dzi &lt; s) break; } x2=mx+dxi; y2=my+dyi; z2=mz+dzi; x3=mx+dx/(0.9*i); y3=my+dy/(0.9*i); z3=mz+dz/(0.9*i); printf(&quot;%8.3f%8.3f%8.3f\\n&quot;,x2,y2,z2); printf(&quot;%8.3f%8.3f%8.3f\\n&quot;,mx*10,my*10,mz*10); printf(&quot;%8.3f%8.3f%8.3f\\n&quot;,x2*10,y2*10,z2*10); printf(&quot;%8.3f%8.3f%8.3f\\n&quot;,x3*10,y3*10,z3*10); printf(&quot;%5d\\n&quot;,i) }' } function fun4 { # 缩放后坐标写入md.gro，一个质心一个偶极箭头点 # echo $1 $2 $3 awk 'BEGIN {FIELDWIDTHS=&quot;5 3 7 5 8 8 8&quot;; num = &quot;'${atom_num[1]}'&quot;;rid = &quot;'${atom_num[0]}'&quot;; x1 = &quot;'$mx'&quot; / 10 ; y1 = &quot;'${my}'&quot; / 10; z1 = &quot;'${mz}'&quot; / 10; x2 = &quot;'${f_dip[0]}'&quot;;y2 = &quot;'${f_dip[1]}'&quot;;z2 = &quot;'${f_dip[2]}'&quot;} {if (NR == 2) print $1+2; else print $0 ; if (NR == num + 2){ printf(&quot;%5d%3s%7s%5d%8.3f%8.3f%8.3f\\n&quot;, rid+1,&quot;LOG&quot;,&quot;CA&quot;,num+1,x1,y1,z1); printf(&quot;%5d%3s%7s%5d%8.3f%8.3f%8.3f\\n&quot;, rid+1,&quot;LOG&quot;,&quot;CA&quot;,num+2,x2,y2,z2) }}' md.gro } function fun5 { # 计算静电偶级与Z轴的夹角Cos theta值 awk '!/^(#|@)/ {theta = $4 / $5; print $0 &quot; &quot; theta}' Mtot.xvg &gt; dipoles } ######################################################### # printf(&quot;%8.3f%8.3f%8.3f\\n&quot;,mx,my,mz); # printf(&quot;%8.3f%8.3f%8.3f\\n&quot;,dx,dy,dz); # fun4 # echo ${atom_num[@]} # echo ${f_dip[@]} # atomselect 0 &quot;protein or resname FAD&quot; # measure center atomselect0 weight mass ######################################################### ### mass center's coordinate (units A) ### mx=$1; my=$2; mz=$3 ### diploes_coordinate ### dip=($(fun1)) echo -e &quot;\\n偶极分量: ${dip[@]}&quot; ### atom_numbers ### atom_num=($(fun2)) echo -e &quot;残基编号&amp;原子总数: ${atom_num[@]}&quot; ### log_atom_coordinate ### f_dip=($(fun3)) echo -e &quot;蛋白质心坐标(A): ${f_dip[3]} ${f_dip[4]} ${f_dip[5]}&quot; echo -e &quot;缩放偶极坐标(A): ${f_dip[6]} ${f_dip[7]} ${f_dip[8]}&quot; echo -e &quot;偶极尖尖坐标(A): ${f_dip[9]} ${f_dip[10]} ${f_dip[11]}&quot; echo -e &quot;缩放次数: ${f_dip[12]}&quot; echo -e &quot;draw cylinder {${f_dip[3]} ${f_dip[4]} ${f_dip[5]}} {${f_dip[6]} ${f_dip[7]} ${f_dip[8]}} radius 0.5 filled yes resolution 20&quot; echo -e &quot;draw cone {${f_dip[6]} ${f_dip[7]} ${f_dip[8]}} {${f_dip[9]} ${f_dip[10]} ${f_dip[11]}} radius 1.5 resolution 20&quot; ### write in gro ### # fun4 &gt; md_dipoles.gro ","link":"https://shxiaj.github.io/post/chox2/"},{"title":"Gromacs程序安装&使用","content":"by DingLiAng cmake安装, 去官网下载Binary distributions二进制版 解压就能用，方便 wget https://github.com/Kitware/CMake/releases/download/v3.22.0-rc2/cmake-3.22.0-rc2-linux-x86_64.tar.gz fftw安装 wget http://www.fftw.org/fftw-3.3.10.tar.gz # 解压 ./configure --prefix=${HOME}/soft/fftw --enable-sse2 --enable-avx --enable-float --enable-shared --enable-avx2 make install -j 4 Gromacs安装，CPU版本 wget ftp://ftp.gromacs.org/pub/gromacs/gromacs-2019.6.tar.gz # 解压，安装fftw，cmake，gcc &gt; 4.8.1; # 注意安装fftw时加上AVX2指令集 tar xvzf xxx cd gromacs mkdir build cd build cmake .. -DCMAKE_INSTALL_PREFIX=指定安装目录 -DGMX_SIMD=AVX2_256 \\ -DCMAKE_PREFIX_PATH=fftw安装目录 \\ -DCMAKE_C_COMPILER=gcc文件全路径 -DCMAKE_CXX_COMPILER=g++文件全路径 # gcc是自己安装的需要指定，系统自带则不需要 # exmaple：cmake .. -DCMAKE_INSTALL_PREFIX=${HOME}/soft/gromacs \\ # -DGMX_SIMD=AVX_256 -DCMAKE_PREFIX_PATH=/public/home/DLA/soft/fftw \\ # -DCMAKE_C_COMPILER=/public/apps/gcc/bin/gcc -DCMAKE_CXX_COMPILER=/public/apps/gcc/bin/g++ make install -j xxx # xxx 为编译时使用的核数，int型 gromacs官网安装手册 CPU参数 # 查看逻辑核心个数 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c # 查看cpu运行频率 cat /proc/cpuinfo |grep MHz|uniq watch grep \\&quot;cpu MHz\\&quot; /proc/cpuinfo # 查看物理CPU个数 cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l # 查看每个物理CPU中core的个数(即核数) cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq # 查看逻辑CPU的个数 cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l Gromacs提交任务 # -nt 指定总线程数，即为所使用的的CPU核数 nohup gmx mdrun -v -deffnm md -nt 28 -ntomp 14 -pinoffset 14 &gt; task.log 2&gt;&amp;1 &amp; # nt = MPI*OpenMP = 任务使用核心数; -ntmpi 指定MPI; -ntomp 指定OpenMP; 测试结果: chox体系进行的测试，8w原子， box = 9 * 9 * 10大约 # 8个CPU，总共256核(实际上是双线程，物理核心数128); 默频2.2Ghz, 全核2.2Ghz switch(MPI * OpenMP) { case：4 * 64 18ns/day case：8 * 32 33ns/day case：16 * 16 39ns/day case：32 * 8 56ns/day case：64 * 4 46ns/day case：128 * 2 48ns/day case：256 * 1 58ns/day # 直接使用-nt 256 case：64 * 1 28ns/day # 真垃圾 } # 2个CPU，总共28核(单线程); 默频2.4Ghz，全核2.8Ghz switch(MPI * OpenMP) { case：2 * 14 17ns/day case：4 * 7 20ns/day case：7 * 4 20ns/day case：28 * 1 28ns/day } 总结 设置OpenMP = 1; MPI设为使用核数，最快。 但可能会出现报错，适当调整即可。 Gromacs2021.3 And GTX3070 And 28核2.7Ghz测试 chox体系进行的测试，8.5w原子，box = 9.99 * 8.65 * 9.85 命令：htop 查看CPU核心以及任务情况 28核双线程，两块CPU，每个逻辑核是完全相同的。 命令：sensors 查看CPU温度 命令：nvidia-smi查看GPU工作情况 重点在于：温度、功耗、利用率 提交命令 gmx mdrun 参数：&quot;-pin on -ntmpi 1 -ntomp 9 -pme gpu -nb gpu -gpu_id 0 -pinoffset 56&quot; -ntomp 99核效果比较好，单个任务GPU利用率52%，体系85ns/day -pinoffset 56 绑定起始CPU核心，调用CPU时会按照顺序调用 pinoffset计算方法：内部编号与htop显示出来的编号并不相同，转换方法：(htop的编号 - 1) * 2 = pinoffset编号 例如：想从htop上面序号为1的核心开始，pinoffset = (1 - 1) * 2 = 0; 第十个开始，pinoffset = 18; -gpu_id 0 0或者1 看GPU喽 核心测试，GPU单个任务 CPU核数 GPU利用率% CPU核数 GPU利用率% 4 40 9 52 5 42 10 53 6 45 14 54 7 48 28 53 8 50 一个GPU两个任务时，利用率82-88%都遇见过，不能到100%，疑惑，但是88%时，GPU功耗将近满载220W，疑惑。 一个GPU一个任务时，测试体系85ns/day * 1，一个GPU两个任务时75ns/day * 2 使用核数7,8,9，认为都可以，按照任务数量调节，任务少就多用，任务多就少用。 一个GPU提交3个任务，每个任务用7个核，利用率最高97%左右，总体速度应该是最优的，实测61ns/day * 3 我的提交方式 #!/usr/bin/bash # 前台执行：./task.sh 2&gt;&amp;1 | tee task.log # 后台执行：nohup ./task.sh &gt; task.log 2&gt;&amp;1 &amp; # 后台查看进程：ps -ef | grep [t]ask.sh function gmxem { gmx grompp -f em.mdp -c ions.gro -p topol.top -o ./em/em.tpr -po ./em/emout.mdp -n gmx mdrun -v -deffnm ./em/em -nt 30 } function gmxnvt { gmx grompp -f nvt.mdp -c ./em/em.gro -p topol.top -o ./nvt/nvt.tpr -po ./nvt/nvtout.mdp -n -r ./em/em.gro gmx mdrun -v -deffnm ./nvt/nvt $logogram } function gmxmd { gmx grompp -f md.mdp -c ./nvt/nvt.gro -p topol.top -o ./md/md.tpr -po ./md/mdout.mdp -n -r ./nvt/nvt.gro gmx mdrun -v -deffnm ./md/md $logogram } function gmxrerun { gmx grompp -f energy.mdp -n -c ./nvt/nvt.gro -p topol.top -o ./energy/energy.tpr -po ./energy/energy.mdp gmx mdrun -v -rerun ./md/md.trr -deffnm ./energy/energy } ############################################################### logogram=&quot;-pin on -ntmpi 1 -ntomp 9 -pme gpu -nb gpu -gpu_id 0 -pinoffset 56&quot; gmxem gmxnvt gmxmd ","link":"https://shxiaj.github.io/post/gmx1/"},{"title":"SAM.sh","content":"好多的酶 PTMC sed -i '/ANISOU/d' 5z0f-single.pdb MD ####################################################################### 创建表面 gmx genconf -f COOH_25%_UnitCell.gro -o sam_cooh.gro -nbox 8 9 1 gmx genconf -f NH2_25%_UnitCell.gro -o sam_cooh.gro -nbox 8 9 1 sed -e '/SBM/d' sam_cooh.gro &gt; sam sed -n -e '/SBM/p' sam_cooh.gro &gt; sbm cat sam sbm &gt; sam_cooh.gro sed -e '/SEM/d' sam_nh2.gro.bak &gt; sdm sed -n -e '/SEM/p' sam_nh2.gro.bak &gt; sem cat sdm sem &gt; sam_nh2.gro ###################################################################### 改下CU标识 echo 1 | gmx pdb2gmx -o protein.gro -water tip3p -f -ignh 留个加墙的空0.2nm gmx editconf -f protein.gro -d 1.2 &amp;&amp; rm out.gro gmx editconf -o protein.gro -d 1.2 -f md_ gmx editconf -f protein.gro -o ptw1.gro -box 7.99184 7.78626 gmx editconf -f protein.gro -o ptw1.gro -box 9.98980 8.65140 gmx editconf -f protein.gro -o ptw1.gro -box 10.98867 10.38168 g_min g_max 蛋白调到底边 g_adj ptw1.gro ptw2.gro gmx editconf -f ptw2.gro -o ptw2.gro -translate 0 0 -0.1 gmx solvate -cp ptw2.gro -cs spc216.gro -o ptw3.gro -p topol.top ## SAMs 负电厚度1.316nm正电厚度1.432 加0.2nm用墙 gmx editconf -f ptw3.gro -o ptw4.gro -translate 0 0 1.539 # 负电 gmx editconf -f ptw3.gro -o ptw4.gro -translate 0 0 1.652 # 正电 合并盒子 g_mer sam_nh3.gro ## 修改top，SAM268 SBM20 建立CU的键 写入AB DE.itp ## 修改top，SAM216 SBM72 建立CA,FE的键 写入AB DE.itp 492 36 # 4563 944 1 0.198 500000.0 # 4563 704 1 0.217 500000.0 # 4564 3608 1 0.191 500000.0 # 4564 3185 1 0.196 500000.0 # 4564 3257 1 0.199 500000.0 // ## 2p3x // # 5330 1322 1 0.207 500000.0 # 5330 1636 1 0.216 500000.0 # 5330 1790 1 0.234 500000.0 # 5331 3696 1 0.204 500000.0 # 5331 3763 1 0.215 500000.0 # 5331 4204 1 0.202 500000.0 // ## 6atj // 687 4695 1 0.232 500000.0 733 4695 1 0.235 500000.0 794 4695 1 0.251 500000.0 2580 4696 1 0.239 500000.0 3434 4696 1 0.248 500000.0 3481 4696 1 0.243 500000.0 2562 4697 1 0.206 500000.0 # 582 4697 1 0.647 500000.0 # 2548 4697 1 0.611 500000.0 mkdir ion em nvt md energy energy1 update user set authentication_string=password(&quot;dingliang&quot;) where user='root'; 插离子 gmx grompp -f ion.mdp -c box.gro -p topol.top -o ./ion/ions.tpr -po ./ion/ionout.mdp -maxwarn 1 gmx genion -s ./ion/ions.tpr -o ions.gro -p topol.top -np 31 -pname NA -pq 1 -nn 0 -nname CL -nq -1 gmx genion -s ./ion/ions.tpr -o ions.gro -p topol.top -np 3 -pname NA -pq 1 -nn 28 -nname CL -nq -1 # cat ions.gro surf-cooh.gro &gt; box.gro 索引 echo -e &quot;a S\\n q&quot; | gmx make_ndx -f ions.gro -o a S q ions.gro留空加0.3nm真空 g_zev ions.gro em nvt md g_free gmx grompp -f em.mdp -c ions.gro -p topol.top -o ./em/em.tpr -po ./em/emout.mdp -n gmx mdrun -v -deffnm ./em/em $logogram2 gmx grompp -f nvt.mdp -c ./em/em.gro -p topol.top -o ./nvt/nvt.tpr -po ./nvt/nvtout.mdp -n -r ./em/em.gro gmx mdrun -v -deffnm ./nvt/nvt -cpi ./nvt/nvt.cpt $logogram gmx grompp -f md.mdp -c ./nvt/nvt.gro -p topol.top -o ./md/md.tpr -po ./md/mdout.mdp -n -r ./nvt/nvt.gro gmx mdrun -v -deffnm ./md/md -cpi ./md/md.cpt $logogram =================================================================================== gmx grompp -f em.mdp -c ions.gro -p topol.top -o ./em/em.tpr -po ./em/emout.mdp -n gmx mdrun -v -deffnm ./em/em gmx grompp -f nvt.mdp -c ./em/em.gro -p topol.top -o ./nvt/nvt.tpr -po ./nvt/nvtout.mdp -n gmx mdrun -v -deffnm ./nvt/nvt # Segmentation fault 能量最小化出问题，重新跑 gmx grompp -f md.mdp -c ./nvt/nvt.gro -p topol.top -o ./md/md.tpr -po ./md/mdout.mdp -n gmx mdrun -v -deffnm ./md/md 分析 gmx trjconv -s md.tpr -f md.xtc -o md_1.xtc -pbc mol -ur compact gmx rms -s md.tpr -f md_1.xtc -o rmsd.xvg -tu ns gmx rmsf -s md.tpr -f md_1.xtc -res -o rmsf.xvg gmx dipoles -f md.xtc -s md.tpr -o -b 0 -e 100000 -a aver.xvg -cos cosaver.xvg gmx distance -s md.tpr -f md_1.xtc -oall -oav -tu ns -select &quot;com of group 1 plus com of group 18&quot; gmx mindist -s md.tpr -f md_1.xtc -od -tu ns # 低版本不支持指定单位 归一化用不上 gmx rdf -s md.tpr -f md_1.xtc -tu ns -o rdf.xvg -cn rdf-cn.xvg echo -e '27\\n30\\n'| gmx rdf -s md.tpr -f md_1.xtc -n ../index.ndx -o -cn -b 80000 # rerun 重跑能量 gmx grompp -f md.mdp -n -c ./nvt/nvt.gro -p topol.top -o ./energy/energy.tpr -po ./energy/energy.mdp gmx mdrun -v -rerun ./md/md.trr -deffnm ./energy/energy gmx energy -s energy.tpr -f energy.edr -o ene-HAP-Cal.xvg awk '! {if ($2 ~ /^[0-9]/ &amp;&amp; \\ $2 &lt; min) min = $2} END {print min}' surf-NH2.gro awk '!/^(#|@)/ {ecc = 1 - (($2 + $3 + $4 ) / 3) / $1; print $0 &quot; &quot; res}' moi.xvg awk '!/^(#|@)/ {ecc = 1 - (($2 + $3 + $4 ) / 3) / $2; print $0 &quot; &quot; ecc}' moi.xvg &gt; tt export PATH=/home/dila/soft/gawk/bin:$PATH awk 'BEGIN {FIELDWIDTHS=&quot;36 8&quot;; min = 100} {if ($2 ~ / [0-9]/) print $2}' ptw1.gro awk '!/^(#|@)/ { print $0 &quot; &quot;}' Mtot.xvg &gt; tt awk '!/^(#|@)/ {cos = $4 / $5; print $0 &quot; &quot; cos}' Mtot.xvg VMD atomselect 0 {protein within 3.5 of resname SDM SEM SAM SBM} atomselect0 writepdb connect_res.pdb set aid [atomselect 0 same residue as {protein within 3.5 of {resname SDM SEM SAM SBM}}] $aid get resid &gt; tt FAD分析 gmx make_ndx -f ./md/md.gro -n echo 0 | gmx trjconv -s md.tpr -f md.trr -o md.xtc -pbc mol -ur compact -skip 3 echo 26 | gmx dipoles -s *.tpr -f *.xtc -n gmx grompp -f energy.mdp -n -c ./nvt/nvt.gro -p topol.top -o ./energy/energy.tpr -po ./energy/energy.mdp gmx mdrun -v -rerun ./md/md.trr -deffnm ./energy/energy $logogram3 gmx energy -s energy.tpr -f energy.edr gmx distance -s md.tpr -f md.xtc -oxyz -tu ns -n -select &quot;[0,0,1.520] plus group 27&quot; ","link":"https://shxiaj.github.io/post/sam/"}]}